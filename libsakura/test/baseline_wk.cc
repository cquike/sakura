/*
 * @SAKURA_LICENSE_HEADER_START@
 * Copyright (C) 2013-2015
 * National Astronomical Observatory of Japan
 * 2-21-1, Osawa, Mitaka, Tokyo, 181-8588, Japan.
 * 
 * This file is part of Sakura.
 * 
 * Sakura is free software: you can redistribute it and/or modify it under 
 * the terms of the GNU Lesser General Public License as published by the 
 * Free Software Foundation, either version 3 of the License, or (at your 
 * option) any later version.
 * 
 * Sakura is distributed in the hope that it will be useful, but WITHOUT 
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
 * License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License 
 * along with Sakura.  If not, see <http://www.gnu.org/licenses/>.
 * @SAKURA_LICENSE_HEADER_END@
 */
/*
 * Test cases to be implemented.
 * functions to be tested include:
 * - sakura_SubtractBaselineCubicSplineFloat
 * - sakura_GetBestFitBaselineCoefficientsCubicSplineFloat
 * test cases are as follows:
 * - for cubic spline functions:
 *     (1) simple successful case
 *     	 for cubic spline ones: (num_pieces=1,2,3, num_data=4*num_pieces+a where a=0,1,2,3,10)
 *     	 for sinusoidal ones: ()
 *     (2) time-consuming successful case for performance measurement
 *     (3) error cases
 *         (3-1) null pointer cases
 *         (3-2) non-aligned array cases
 *         (3-3) bad parameter value cases
 */

#include <cmath>
#include <iostream>
#include <random>
#include <string>
#include <sys/time.h>

#include <libsakura/sakura.h>
#include <libsakura/localdef.h>
#include "loginit.h"
#include "aligned_memory.h"
#include "gtest/gtest.h"
#include "baseline.h"

/* the number of elements in input/output array to test */
#define NUM_DATA 5
#define NUM_DATA2 15
#define NUM_DATA3 4096
#define NUM_MODEL 3
#define NUM_REPEAT 20000
#define NUM_MODEL2 4
#define NUM_REPEAT2 2000000

using namespace std;

/*
 * A super class to test baseline functions
 */
class BaselineWK: public ::testing::Test {
protected:

	BaselineWK() :
			verbose(false) {
	}

	virtual void SetUp() {
		// Initialize sakura
		LIBSAKURA_SYMBOL (Status) status = LIBSAKURA_SYMBOL(Initialize)(nullptr,
				nullptr);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), status);
	}

	virtual void TearDown() {
		LIBSAKURA_SYMBOL(CleanUp)();
	}

	// Set (1+x+x*x) float values into an array
	void SetFloatPolynomial(size_t const num_data, float *data) {
		for (size_t i = 0; i < num_data; ++i) {
			double x = (double) i;
			data[i] = (float) (1.0 + x + x * x);
		}
	}

	//Set (A[0]+A[1]*x+A[2]*x*x+A[3]*x*x*x) float values into an array
	void SetFloatPolynomial(size_t num_data, float *data,
			double *coeff_answer) {
		for (size_t i = 0; i < num_data; ++i) {
			double x = (double) i;
			data[i] = (float) (coeff_answer[0] + coeff_answer[1] * x
					+ coeff_answer[2] * x * x + coeff_answer[3] * x * x * x);
		}
	}

	//Set sinusoidal values of float into an array
	void SetFloatSinusoidal(size_t num_nwave, size_t const *nwave,
			double const *coeff, size_t num_data, float *data) {
		double factor = 2.0 * M_PI / (double) (num_data - 1);
		for (size_t i = 0; i < num_data; ++i) {
			data[i] = 0.0f;
			double x = factor * (double) i;
			size_t coeff_idx = 0;
			for (size_t j = 0; j < num_nwave; ++j) {
				//amplitude of each sinusoid is unity
				if (nwave[j] == 0) {
					data[i] += coeff[coeff_idx++];
				} else {
					double theta = nwave[j] * x;
					data[i] += (float) (coeff[coeff_idx++] * sin(theta));
					data[i] += (float) (coeff[coeff_idx++] * cos(theta));
				}
			}
		}
	}

	// Set constant float values into an array
	void SetFloatConstant(float value, size_t const num_data, float *data) {
		for (size_t i = 0; i < num_data; ++i) {
			data[i] = value;
		}
	}

	// Set constant float plus Gaussian noise values into an array
	void SetFloatConstantWithGaussianNoise(float value, float sigma,
			size_t const num_data, float *data) {
		std::random_device rd;
		std::mt19937 mt(rd());
		std::normal_distribution<> out(value, sigma);
		for (size_t i = 0; i < num_data; ++i) {
			data[i] = out(mt);
		}
	}
	// Set constant double values into an array
	void SetDoubleConstant(double value, size_t const num_data, double *data) {
		for (size_t i = 0; i < num_data; ++i) {
			data[i] = value;
		}
	}
	// Set constant boolean values into an array
	void SetBoolConstant(bool value, size_t const num_data, bool *data) {
		for (size_t i = 0; i < num_data; ++i) {
			data[i] = value;
		}
	}

	// Check if the expected and actual values are enough close to each other
	void CheckAlmostEqual(double expected, double actual, double tolerance) {
		double deviation = fabs(actual - expected);
		double val = max(fabs(actual), fabs(expected)) * tolerance + tolerance;
		ASSERT_LE(deviation, val);
	}

	//1D float array
	void PrintArray(char const *name, size_t print_length, float const *data,
			size_t start_idx = 0, bool print_name = true, bool newline = true) {
		if (print_name)
			cout << name << " = ";
		cout << "[";
		for (size_t i = start_idx; i < start_idx + print_length - 1; ++i)
			cout << data[i] << ", ";
		cout << data[start_idx + print_length - 1];
		cout << " ]";
		if (newline)
			cout << endl;
	}
	//1D double array
	void PrintArray(char const *name, size_t print_length, double const *data,
			size_t start_idx = 0, bool print_name = true, bool newline = true) {
		if (print_name)
			cout << name << " = ";
		cout << "[";
		for (size_t i = start_idx; i < start_idx + print_length - 1; ++i)
			cout << data[i] << ", ";
		cout << data[start_idx + print_length - 1];
		cout << " ]";
		if (newline)
			cout << endl;
	}
	//1D bool array
	void PrintArray(char const *name, size_t print_length, bool const *data,
			size_t start_idx = 0, bool print_name = true, bool newline = true) {
		if (print_name)
			cout << name << " = ";
		cout << "[";
		for (size_t i = start_idx; i < start_idx + print_length - 1; ++i)
			cout << (data[i] ? "T" : "F") << ", ";
		cout << (data[start_idx + print_length - 1] ? "T" : "F");
		cout << " ]";
		if (newline)
			cout << endl;
	}
	//given as 1D float array but actually stores (num_row * num_column) 2D data
	//for which column loop comes inside row loop.
	void PrintArray(char const *name, size_t num_row, size_t num_column,
			float const *data) {
		cout << name << " = [";
		for (size_t i = 0; i < num_row; ++i) {
			PrintArray(name, num_column, data, num_column * i, false, false);
			if (i < num_row - 1)
				cout << ", " << endl;
		}
		cout << " ]" << endl;
	}
	//given as 1D double array but actually stores (num_row * num_column) 2D data
	//for which column loop comes inside row loop.
	void PrintArray(char const *name, size_t num_row, size_t num_column,
			double const *data) {
		cout << name << " = [";
		for (size_t i = 0; i < num_row; ++i) {
			PrintArray(name, num_column, data, num_column * i, false, false);
			if (i < num_row - 1)
				cout << ", " << endl;
		}
		cout << " ]" << endl;
	}

	bool verbose;
	uint16_t const dummy_nwave = 0;

};

/*
 * Test GetBestFitBaselineCoefficientsCubicSpline
 * successful case
 * compute the best-fit baseline coefficients for cubic spline
 * for cases of combination of num_pieces=(1,2,3) and num_data=(4*num_pieces+a) where a=(0,1,2,3)
 */
TEST_F(BaselineWK, GetBestFitBaselineCoefficientsCubicSplineSuccessfulCase) {
	uint16_t const order = 0;
	for (size_t num_pieces = 1; num_pieces <= 3; ++num_pieces) {
		cout << "    Testing for num_pieces = " << num_pieces
				<< " cases: num_data = ";
		size_t num_extra_max = 3;
		for (size_t num_extra = 0; num_extra <= num_extra_max; ++num_extra) {
			SIMD_ALIGN
			double coeff[4 * num_pieces];
			SetDoubleConstant(1.0, ELEMENTSOF(coeff), coeff);
			size_t const num_data(ELEMENTSOF(coeff) + num_extra);
			SIMD_ALIGN
			float in_data[num_data];
			SetFloatPolynomial(num_data, in_data, coeff);
			SIMD_ALIGN
			bool mask[ELEMENTSOF(in_data)];
			SetBoolConstant(true, ELEMENTSOF(in_data), mask);
			cout << num_data << ((num_extra < num_extra_max) ? ", " : "");
			if (verbose) {
				PrintArray("in_data", num_data, in_data);
			}
			LIBSAKURA_SYMBOL(BaselineContext) * context = nullptr;
			LIBSAKURA_SYMBOL (Status) create_status =
					sakura_CreateBaselineContext(
							LIBSAKURA_SYMBOL(BaselineType_kCubicSpline), order,
							num_pieces, dummy_nwave, num_data, &context);
			EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
			SIMD_ALIGN
			double out[ELEMENTSOF(coeff)];
			double answer[ELEMENTSOF(coeff)];
			for (size_t i = 0; i < ELEMENTSOF(coeff); ++i) {
				answer[i] = coeff[i];
			}
			float rms;
			SIMD_ALIGN
			double boundary[num_pieces];

			LIBSAKURA_SYMBOL(BaselineStatus) baseline_status;
			LIBSAKURA_SYMBOL (Status) coeff_status = LIBSAKURA_SYMBOL(
					GetBestFitBaselineCoefficientsCubicSplineFloat)(context,
					num_data, in_data, mask, 5.0f, 1, num_pieces, out, mask,
					&rms, boundary, &baseline_status);
			EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), coeff_status);
			EXPECT_EQ(LIBSAKURA_SYMBOL(BaselineStatus_kOK), baseline_status);

			for (size_t i = 0; i < ELEMENTSOF(answer); ++i) {
				CheckAlmostEqual(answer[i], out[i], 1.0e-6);
			}

			if (verbose) {
				PrintArray("data  ", num_data, in_data);
				PrintArray("out   ", ELEMENTSOF(answer), out);
				PrintArray("answer", ELEMENTSOF(answer), answer);
			}

			LIBSAKURA_SYMBOL (Status) destroy_status =
					sakura_DestroyBaselineContext(context);
			EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);
		}
		cout << endl;
	}
}

/*
 * Temporary test case using ALMA SD data to follow user testing of a CASA task
 * tsdbaseline by Junko Ueda. Used data is the pol=0 spectrum of the first row
 * from uid___A002_X85c183_X36f (calibrated).
 * 2015/4/8 WK
 */
TEST_F(BaselineWK, GetBestFitBaselineCoefficientsCubicSplineSuccessfulCaseForCAS6999) {
	uint16_t const order = 0;
	for (size_t num_pieces = 1; num_pieces <= 10; ++num_pieces) {
		/*
		 cout << "    Testing for num_pieces = " << num_pieces
		 << " cases: num_data = ";
		 */
		size_t num_extra_max = 0;	//3;
		for (size_t num_extra = 0; num_extra <= num_extra_max; ++num_extra) {
			SIMD_ALIGN
			double coeff[4 * num_pieces];
			SetDoubleConstant(1.0, ELEMENTSOF(coeff), coeff);
			size_t const num_data = 4080;
			SIMD_ALIGN
			float in_data[num_data] = { 0.0142482891679, -0.0291637405753,
					0.00779710942879, 0.0181236378849, 0.0748615264893,
					0.0820204764605, -0.0107036205009, -0.0488131530583,
					-0.0162396728992, -0.0431624613702, -0.0727756991982,
					-0.00196782662533, 0.102950692177, 0.165748804808,
					0.156050756574, 0.0502862408757, -0.0319176986814,
					-0.0417070165277, -0.0325784273446, 0.0171001497656,
					0.0775953158736, -0.00298920809291, -0.115855894983,
					-0.103611439466, -0.10150308907, -0.0768763870001,
					0.00844649598002, -0.0376194790006, -0.164684638381,
					-0.143690526485, -0.113391563296, -0.0583587549627,
					0.00587591901422, -0.0758894383907, 0.00896087102592,
					0.203575491905, 0.13509568572, -0.0176854189485,
					0.0339350104332, 0.114613167942, 0.0484133176506,
					-0.0568311884999, -0.133869081736, -0.130238220096,
					-0.0265150796622, 0.0698143988848, 0.0827575176954,
					0.0265901461244, -0.00261666066945, 0.0714628919959,
					0.0736147239804, 0.0438374653459, 0.0878191143274,
					0.067823804915, 0.0540942363441, 0.0633623674512,
					0.0243235267699, 0.0146590033546, 0.041858214885,
					0.0602680258453, 0.0302225090563, -0.0246807839721,
					-0.0349010489881, -0.0590447373688, -0.0579480789602,
					-0.00448911078274, -0.00776710826904, -0.0817634314299,
					-0.0809434428811, 0.0311590842903, 0.0357450135052,
					-0.00611882004887, 0.0506737045944, 0.0566942840815,
					0.015447084792, -0.000446100777481, -0.0279361717403,
					-0.0161757972091, 0.0406548045576, 0.075515575707,
					0.0402790009975, -0.00338542857207, 0.0313108935952,
					0.0600752942264, -0.00380143499933, -0.0509281158447,
					0.0242537539452, 0.060119971633, 0.0325284935534,
					0.0746073424816, 0.0912915095687, 0.0242893099785,
					-0.0005356753245, 0.0373210981488, 0.0232494082302,
					-0.0167170744389, -0.022450812161, 0.0072678187862,
					0.0175849180669, -0.00458679161966, -0.0212988890707,
					-0.0491495244205, -0.0720270425081, -0.10533605516,
					-0.123004175723, -0.056706186384, 0.00817388668656,
					-0.0210393071175, -0.00439832452685, 0.0289513356984,
					-0.0170407053083, -0.0203573424369, -0.0349556058645,
					-0.0826428085566, -0.0276262331754, 0.0695528686047,
					0.0453838668764, 0.00115976645611, 0.0511092990637,
					0.0591419190168, 0.0364559479058, 0.068009339273,
					0.0444005355239, 0.0190135501325, 0.142217293382,
					0.177351459861, -0.00265140272677, -0.115053199232,
					-0.0652121454477, -0.0262483004481, -0.00720498431474,
					0.0579618252814, 0.108901187778, 0.111003659666,
					0.0780099630356, 0.0697450190783, 0.0710957422853,
					-0.0402320846915, -0.0983468741179, 0.00605125399306,
					0.107981160283, 0.113453239202, 0.0428111664951,
					0.0264705307782, 0.0659052059054, 0.0411165691912,
					0.00511156674474, 0.000882885709871, -0.0292460508645,
					-0.0518321953714, -0.0518820621073, -0.0614801086485,
					-0.0203318111598, 0.0632891282439, 0.102518312633,
					0.0114009734243, -0.106536611915, -0.0572483465075,
					0.000353060924681, -0.0179406367242, -0.0261624157429,
					-0.0530528649688, -0.0829845666885, -0.0596136674285,
					0.0185144469142, 0.0209943000227, -0.0554059743881,
					-0.0685161501169, -0.0361988544464, -4.64440017822e-05,
					0.0639805495739, 0.100688368082, 0.0575050525367,
					0.0297599956393, 0.0318773947656, 0.0109693426639,
					0.014535844326, 0.0446101501584, -0.000956650997978,
					-0.0170291271061, 0.0189468432218, -0.0136945135891,
					-0.0922662839293, -0.0874590575695, -0.0073369317688,
					-0.0225306320935, -0.0222099795938, 0.0410947389901,
					0.105712145567, 0.145829692483, 0.0866721943021,
					-0.0274556409568, -0.103014394641, -0.0595485828817,
					0.0713739320636, 0.085785202682, -0.0205917488784,
					-0.0421069897711, 0.0012814423535, 0.0183021370322,
					0.0435476712883, 0.0474082678556, 0.0486135110259,
					0.0566803067923, -0.0245274379849, -0.0647505968809,
					-0.0105805285275, 0.00402137124911, -0.0614020526409,
					-0.108113177121, -0.0887535512447, -0.0186793524772,
					0.0631801709533, 0.0394353456795, -0.0122879557312,
					-0.00185733439866, 0.0164601001889, 0.0114595554769,
					-0.00784775614738, -0.0469898954034, -0.0798474177718,
					-0.087775953114, -0.0714197680354, -0.0532794743776,
					0.0185535494238, 0.143617197871, 0.13574911654,
					0.0718510895967, 0.0953079909086, 0.0553114041686,
					-0.0360359624028, -0.0550099276006, -0.0314085707068,
					0.0474835410714, 0.150033026934, 0.116015702486,
					-0.00615597516298, -0.0708406567574, -0.0904394090176,
					-0.0400467254221, 0.0607903376222, 0.0709439888597,
					-0.0172151830047, -0.0240749884397, 0.0615036152303,
					0.0944607332349, 0.0553945824504, -0.00386626739055,
					0.0502896457911, 0.138585135341, 0.0930063501,
					-0.000783577095717, -0.0323988161981, 0.00630615791306,
					-0.000919648387935, -0.0430686473846, -0.0348199754953,
					-0.00926218181849, -0.0355707332492, -0.112821340561,
					-0.124729909003, -0.0439414680004, 0.0260599032044,
					-0.0296399835497, -0.0676885917783, 0.0264208428562,
					0.0686235129833, 0.0365069918334, -0.0447322390974,
					-0.0801832973957, -0.0462022982538, -0.104233697057,
					-0.116322264075, -0.0611202046275, -0.0504193678498,
					-0.00360293127596, 0.0329890809953, 0.0256122183055,
					0.028962276876, 0.0643326193094, 0.0518884062767,
					0.0108145549893, 0.102252356708, 0.203093156219,
					0.199547946453, 0.117111809552, 0.0332276523113,
					0.0394451916218, 0.0301881730556, -0.0375175923109,
					-0.081712603569, -0.0832357630134, -0.0978813618422,
					-0.0658161714673, 0.0115350503474, 0.034114703536,
					0.0469114258885, 0.0746291726828, 0.0509121492505,
					0.0245583578944, -4.67687314085e-05, -0.0177801121026,
					0.0457849577069, 0.00132897531148, -0.143518656492,
					-0.141841426492, -0.0929023772478, -0.082340836525,
					-0.0449790358543, -0.0419610776007, -0.0831880867481,
					-0.100454472005, -0.111029066145, -0.0966803580523,
					-0.00643342686817, 0.0737355351448, 0.0396093800664,
					-0.0116448085755, -0.0148613890633, 0.00872981455177,
					0.0781980007887, 0.0663336962461, -0.0234427601099,
					-0.116507552564, -0.13805924356, -0.00659225136042,
					0.0126136057079, -0.0709576532245, -0.0982640311122,
					-0.138273850083, -0.0834010913968, -0.00950973574072,
					-0.0492736026645, -0.0573372654617, 0.0539721772075,
					0.0956533849239, -0.0157381985337, -0.0538796856999,
					-0.0308889895678, -0.0394658669829, -0.00238642841578,
					0.00136154307984, -0.0481563732028, -0.0356616042554,
					0.0434063524008, 0.0987350940704, 0.0907794982195,
					0.0741629749537, 0.0198381561786, -0.0383742004633,
					0.00757364369929, 0.0757300406694, 0.0909025371075,
					0.01656312868, -0.00450138188899, 0.0243660844862,
					-0.0640660822392, -0.106740325689, -0.0364471636713,
					0.0380103513598, 0.060861505568, 0.0643681436777,
					0.0686027631164, 0.0423323512077, 0.0451289564371,
					0.0943468660116, 0.117722079158, 0.15934753418,
					0.181633144617, 0.162193626165, 0.075139939785,
					-0.00161836389452, 0.0226956568658, -0.0165618788451,
					-0.0334928780794, 0.0359727032483, 0.113118328154,
					0.11577873677, 0.062635332346, -0.00464610848576,
					-0.0496391877532, -0.0120316520333, -0.026681188494,
					-0.0336185544729, 0.0630673840642, 0.0965638831258,
					0.0381005220115, 0.015061635524, -0.0252598375082,
					-0.0753537118435, -0.0755357667804, -0.0633349493146,
					-0.067188359797, -0.0638185665011, -0.0509223155677,
					-0.102129757404, -0.073940128088, 0.0641152709723,
					0.116304174066, 0.0586306340992, 0.0266227945685,
					0.0714229345322, 0.0640328973532, -0.023846577853,
					-0.091972887516, -0.0958085954189, -0.0103865340352,
					0.125652119517, 0.13639497757, -0.00555113470182,
					-0.055788487196, -0.0492880940437, -0.024379843846,
					-0.00864632427692, -0.094194278121, -0.129923209548,
					-0.0892870947719, -0.0645118877292, -0.0341762676835,
					0.0712873935699, 0.13045451045, 0.0518331378698,
					0.00860266014934, 0.133791804314, 0.110894426703,
					-0.105274856091, -0.161222487688, -0.0948829129338,
					-0.0374177396297, 0.0295686181635, 0.0429777354002,
					-0.00913401972502, -0.0669779703021, -0.0510846674442,
					0.0150005621836, -0.0154146850109, -0.00657678116113,
					0.0447782874107, -0.00956665631384, -0.0553293377161,
					-0.0365318916738, 0.0318171046674, 0.0788512378931,
					0.0512379594147, 0.01495152805, -0.0486435294151,
					-0.0986053869128, -0.0989467799664, -0.104911491275,
					-0.12255948782, -0.102208666503, 0.00778510607779,
					0.0506637021899, -0.0248482078314, 0.00697132758796,
					0.0907573178411, 0.0894856378436, 0.107014708221,
					0.14589010179, 0.173972383142, 0.1692289114,
					0.0993552207947, 0.0229699127376, -0.0402001701295,
					-0.0938108190894, -0.0214123502374, 0.0410600751638,
					0.000896888785064, 0.0477053448558, 0.0359327942133,
					-0.0968097299337, -0.148158818483, -0.0326172374189,
					0.0494404360652, -0.00914993882179, -0.0481187626719,
					0.0333685316145, 0.0687344297767, -0.0536886937916,
					-0.0692840069532, 0.015926875174, -0.0173816476017,
					-0.074953250587, -0.0951240509748, -0.0604037158191,
					-0.00197641085833, -0.0430411398411, -0.0745796337724,
					-0.0147075559944, 0.00951703824103, -0.032057851553,
					-0.0528469905257, -0.0298028998077, -0.015264749527,
					-0.0616789236665, -0.0411423221231, 0.0181639250368,
					-0.0260911509395, -0.0820237472653, -0.0447827205062,
					0.00195761979558, 0.00843470450491, 0.0367237962782,
					0.027436632663, -0.0591518580914, -0.0760501772165,
					0.0144613739103, 0.00519727356732, -0.00687305768952,
					0.0966547504067, 0.106429614127, 0.0492333583534,
					-0.0232725124806, -0.0858312919736, -0.0326117277145,
					0.0442944914103, 0.0337875448167, 0.00399956526235,
					0.000129844731418, 0.0196791775525, 0.106263130903,
					0.132659479976, 0.105323947966, 0.0865089893341,
					0.0649504065514, 0.0969752520323, 0.0958881527185,
					0.104179039598, 0.196658834815, 0.181810095906,
					0.0548513904214, -0.0224240105599, -0.0216892287135,
					0.0195294041187, 0.0804560706019, 0.175415948033,
					0.178038239479, 0.0443428754807, -0.0137973688543,
					-0.00177873671055, -0.0433397628367, -0.0914310291409,
					-0.0719842016697, -0.0784126520157, -0.0764630511403,
					0.0175002794713, 0.050763938576, -0.0178096145391,
					-0.114175006747, -0.0391999185085, 0.124014392495,
					0.110092118382, 0.0255571864545, -0.0371486656368,
					-0.0528532676399, -0.00812986120582, -0.0181392654777,
					-0.0758428126574, -0.0653103441, 0.00420004781336,
					0.0397645607591, 0.058611612767, 0.0707002654672,
					-0.00733917066827, -0.141153022647, -0.111297264695,
					0.0469292327762, 0.025610357523, -0.0453301072121,
					-0.0285474117845, -0.009087478742, 0.0640337616205,
					0.0703656300902, -0.0464410111308, -0.096780911088,
					-0.0323333144188, 0.0282322838902, 0.0291769765317,
					-0.0263549666852, -0.069796949625, -0.0669627934694,
					-0.065704151988, -0.0184486974031, 0.0429215282202,
					0.0298467539251, -0.0602677427232, -0.100182771683,
					0.0416092425585, 0.109469711781, 0.0166633464396,
					-0.0178831275553, -0.0192242339253, -0.0541127435863,
					-0.0629888027906, -0.00806523580104, 0.0547212772071,
					0.0362322106957, -0.0186033863574, 0.023858550936,
					0.0607098676264, 0.0687776729465, 0.0975587964058,
					0.0913682430983, 0.145493730903, 0.142850682139,
					0.0300756003708, 0.00789059698582, 0.0840155333281,
					0.0937812700868, 0.00737278070301, 0.0106881279498,
					0.0767143368721, 0.0842356085777, 0.0757455900311,
					0.00997798983008, -0.0470368489623, 0.0226398464292,
					0.0796146541834, 0.0200534891337, -0.0177476331592,
					0.0408582761884, 0.0719683468342, 0.0747291296721,
					0.0947569981217, 0.0303175579756, -0.0829449743032,
					-0.0494698286057, 0.0942328944802, 0.0907725468278,
					0.0186206437647, -0.00045623065671, -0.0778305307031,
					-0.166745111346, -0.146568387747, -0.0895375311375,
					-0.0264507122338, 0.0594623908401, 0.109223790467,
					0.120900899172, 0.117862746119, 0.0616070441902,
					-0.00656150747091, 0.0150105440989, 0.0671872496605,
					0.111680321395, 0.141205310822, 0.137659415603,
					0.073827534914, -0.0186494272202, -0.0294001307338,
					-0.0122697660699, -0.0106746926904, 0.0449993759394,
					0.0775536298752, 0.0674876943231, 0.068289577961,
					0.0487509407103, -0.025796091184, -0.113162137568,
					-0.102839976549, -0.00346850790083, 0.00730968965217,
					-0.0649525821209, -0.0581037327647, -0.016200998798,
					0.0395711287856, 0.0809904262424, 0.0902582257986,
					0.0676079764962, 0.00250535062514, 0.036225605756,
					0.10140734911, 0.115427561104, 0.12626542151,
					0.122361592948, 0.103161938488, 0.00452722935006,
					-0.0727067515254, -0.0655584037304, -0.0195933319628,
					0.0532725006342, 0.0865637585521, 0.0404078327119,
					-0.0170175246894, 0.0071309604682, 0.0502665676177,
					0.0271792337298, -0.00111720967107, 0.0178204029799,
					0.0141574088484, 0.0410232022405, 0.0916815847158,
					0.0383121185005, -0.0464255139232, -0.0658966600895,
					-0.0656908452511, -0.0857010930777, -0.107527755201,
					-0.132844269276, -0.177303120494, -0.148138046265,
					-0.104572340846, -0.0944511517882, -0.000978236552328,
					0.0693196058273, -0.00282349414192, -0.0762710869312,
					0.00499102659523, 0.106836393476, 0.0513868443668,
					-0.0537173226476, -0.0212477482855, 0.0600824579597,
					0.00610466860235, -0.0474021062255, -0.0253815483302,
					-0.0248497314751, 0.00879936292768, 0.0883605331182,
					0.116771459579, 0.0430506058037, -0.0367635078728,
					-0.0218371693045, 0.0379126928747, 0.0780517309904,
					0.0588486045599, 0.0485837161541, 0.0681564882398,
					-0.00156938668806, -0.0678702741861, -0.0338402688503,
					0.0304788332433, 0.0760750249028, 0.0858552008867,
					0.0716510117054, 0.0608864240348, 0.0334213599563,
					0.00669411569834, 0.045382719487, 0.094313070178,
					0.0695548355579, 0.0408630408347, 0.0597308501601,
					0.0670347437263, 0.00714421179146, -0.00348274409771,
					0.0308515876532, 0.0182169470936, 0.062298104167,
					0.064526706934, -0.0395254381001, -0.0538291968405,
					0.0531646236777, 0.0839063078165, 0.0191922876984,
					-0.0295561030507, 0.0221760664135, 0.0509443543851,
					-0.00479751173407, 0.0109945526347, 0.0860997140408,
					0.133527398109, 0.097144305706, 0.00835633650422,
					0.036007668823, 0.0547566786408, -0.0567992739379,
					-0.0928184762597, -0.0406578183174, 0.0119791030884,
					0.0402697958052, 0.0100106699392, 0.0121508892626,
					0.0596041604877, 0.0582772567868, 0.0440532304347,
					0.0262703299522, -0.0175394546241, -0.0768948569894,
					-0.128193259239, -0.0799050927162, 0.0330663360655,
					0.0578441023827, 0.0365480817854, -0.00148114748299,
					-0.0734357386827, -0.158188402653, -0.181759089231,
					-0.0814159661531, 0.0297590550035, 0.0716719925404,
					0.0147988880053, -0.109502509236, -0.127743884921,
					-0.0248477682471, 0.011817952618, -0.034944344312,
					-0.0409090742469, 0.0421670414507, 0.126964956522,
					0.0989983305335, 0.0487815588713, 0.0434599667788,
					-0.0213934089988, -0.0413228645921, 0.012016906403,
					0.0377723649144, 0.0749853700399, 0.119580864906,
					0.0913309156895, -0.0195850580931, -0.0173977464437,
					0.0728203654289, 0.0437836162746, 0.0232552736998,
					0.063580006361, 0.057350680232, 0.0224922597408,
					-0.0553712248802, -0.101558044553, 0.00178356550168,
					0.0987797603011, 0.0122629683465, -0.0862557440996,
					-0.0101960282773, 0.07259555161, 0.055856179446,
					0.05689483881, 0.048957426101, 0.0700654760003,
					0.049561355263, -0.0401783026755, 0.0188130401075,
					0.0698570460081, 0.0325135886669, -0.00262918742374,
					-0.0469391830266, 0.0387280322611, 0.166698470712,
					0.154993340373, 0.070532374084, 0.0193380154669,
					0.0131098004058, 0.038528110832, 0.0777544006705,
					0.0685047805309, 0.0866024047136, 0.0729070305824,
					-0.00641042925417, -0.0264068320394, -0.0509061068296,
					-0.0451008453965, 0.0159602519125, -0.0172457061708,
					-0.0622231736779, 0.00623424071819, 0.0261362828314,
					-0.0259156227112, -0.0295659992844, -0.0104859061539,
					0.099365234375, 0.175864860415, 0.0872340202332,
					0.0138264298439, 0.0526877082884, 0.0557833500206,
					-0.0111201778054, -0.101017281413, -0.141723319888,
					-0.0733789429069, -0.0269164815545, -0.0195313896984,
					-0.0331536754966, 0.00513607542962, 0.0874962955713,
					0.0898796692491, 0.0488407164812, 0.05030047521,
					0.0390724614263, -0.0021133965347, 0.0285114459693,
					0.0555632039905, -0.0136617720127, -0.0182816367596,
					0.0104751437902, -0.0342753455043, 0.00395739031956,
					0.0903786271811, 0.0517623275518, 0.0326680876315,
					0.0509112365544, -0.0184174478054, -0.0273959562182,
					0.0696614980698, 0.111947663128, 0.056791074574,
					0.0750020965934, 0.103115022182, 0.0405117869377,
					0.0115431882441, 0.0435147993267, 0.122964531183,
					0.144767358899, 0.0233757290989, -0.103411532938,
					-0.0910099670291, -0.0297064241022, 0.0509172081947,
					0.16065120697, 0.124791905284, 0.00880206096917,
					0.00113443098962, 0.0230599921197, -0.0547129139304,
					-0.13218280673, -0.0965704321861, -0.0677305981517,
					-0.0580448061228, 0.0109113017097, 0.00894981250167,
					-0.0481633655727, -0.00916262343526, -0.00853404495865,
					-0.0227257031947, 0.0727567896247, 0.0860672742128,
					0.0108397025615, 0.0243144109845, 0.0567620806396,
					0.0227068196982, -0.0454440414906, -0.0921690091491,
					-0.0290957987309, 0.033816639334, 0.048473585397,
					0.0221106819808, -0.0116554964334, 0.00879619456828,
					0.0296957623214, 0.0635473877192, 0.12028002739,
					0.154442042112, 0.132128313184, 0.0634322017431,
					0.01858827658, -0.00451510259882, 0.00667609833181,
					0.0386922210455, -0.00828670710325, -0.0242355018854,
					-0.0520734451711, -0.0839115381241, -0.0416078828275,
					-0.00910123251379, -0.016884515062, -0.028361890465,
					0.047037653625, 0.145738258958, 0.138792932034,
					0.0124105541036, -0.0327983684838, 0.0535155534744,
					0.110331371427, 0.110197506845, 0.0888632386923,
					0.0569737777114, 0.000847775838338, -0.0188731085509,
					-0.012722807005, -0.0489738769829, -0.0464688055217,
					0.0381725504994, 0.101574294269, 0.104338556528,
					0.0582833774388, -0.0297933705151, -0.0767535865307,
					-0.0465681962669, 0.000424262718298, 0.0628839582205,
					0.0692800581455, 0.00178583827801, -0.0493440926075,
					-0.0904325991869, -0.0620187036693, 0.0533965677023,
					0.0804987996817, 0.0168934483081, -0.0373629555106,
					-0.10702842474, -0.135332629085, -0.154674217105,
					-0.104172311723, 0.00395536515862, 0.00272560026497,
					-0.0091022355482, 0.00630167685449, 0.0531787797809,
					0.111995346844, 0.027478614822, -0.0963866040111,
					-0.0947440490127, -0.0243543237448, 0.0949735566974,
					0.11882276088, 0.0141113707796, -0.0566356219351,
					-0.0623985528946, -0.0152045311406, -0.00343926623464,
					-0.0232027936727, -0.00411646720022, 0.00928636360914,
					-0.00771500170231, -0.0197676867247, -0.0221312325448,
					-0.0349052585661, 0.0113045535982, 0.067658893764,
					0.0408625379205, 0.0270527433604, 0.0718364715576,
					0.100853972137, 0.0665334686637, -0.0100693926215,
					-0.0790632590652, -0.0406844839454, 0.0599288530648,
					0.0480491369963, 0.0410115793347, 0.0701080411673,
					-0.0138976322487, -0.031105145812, 0.0740024968982,
					0.0895823687315, 0.0219358224422, -0.0318703576922,
					0.017833577469, 0.0266148932278, -0.0463654771447,
					-0.00431523006409, 0.0517063811421, 0.0463853217661,
					0.0335523784161, 0.0195768829435, 0.0126547385007,
					-0.0362144932151, -0.0576220266521, 0.00284379580989,
					0.00438226480037, 0.0194181390107, 0.0771129727364,
					0.0754233971238, 0.0242277048528, 0.0075379149057,
					0.064910903573, 0.0971668809652, 0.071416310966,
					0.0761188715696, 0.0764309689403, 0.0172273404896,
					-0.0268009752035, -0.00350862601772, 0.0482137948275,
					0.0823863968253, 0.0923161357641, 0.0683617144823,
					0.0272425152361, 0.0294766798615, 0.0497670993209,
					0.0211819969118, 0.0124446153641, 0.041489765048,
					-0.01000529062, -0.068839430809, -0.00179520063102,
					0.0505393221974, -0.000656603835523, -0.0332627855241,
					-0.042206466198, -0.0350129753351, 0.00816883891821,
					-0.0234769172966, -0.0237522479147, 0.0829948335886,
					0.142054185271, 0.0392667613924, -0.0398793965578,
					0.0422363691032, 0.0425274372101, 0.0106017580256,
					0.0300819985569, 0.0135303866118, 0.0447573885322,
					0.102512449026, 0.0790168941021, 0.0038496600464,
					0.00335760787129, 0.014336226508, 0.000456728914287,
					0.0656234920025, 0.0743726044893, 0.0403031259775,
					0.0670503899455, 0.0847624391317, 0.0047582979314,
					-0.055801499635, 0.0457554087043, 0.0924972891808,
					0.018646594137, 0.0329038724303, 0.124249570072,
					0.102713525295, -0.00167260749731, -0.046070959419,
					-0.0261168908328, 0.0353015772998, 0.10629247129,
					0.111310362816, 0.0785848647356, 0.0784134566784,
					0.0564846843481, 0.0130341965705, -0.0210884865373,
					-0.0244755763561, 0.00954519957304, 0.00175118108746,
					-0.0359388291836, -0.0603482685983, -0.0347767435014,
					0.0368329659104, 0.0392034724355, -0.0241908244789,
					-0.0908702611923, -0.103594817221, -0.00838355440646,
					0.0677140131593, 0.0510451719165, 0.0544210113585,
					0.0858150571585, 0.110993936658, 0.0742283016443,
					-0.0275725312531, -0.0144393276423, 0.109173290431,
					0.150216504931, 0.056668177247, 0.0021280546207,
					0.00933815632015, -0.0398796088994, -0.0405030176044,
					0.0691081732512, 0.107858106494, -0.011833416298,
					-0.048913102597, 0.0197157729417, 0.0174171309918,
					0.0103423856199, 0.0410277619958, 0.0662449076772,
					0.0740428566933, 0.0423568859696, -0.000794826541096,
					-0.0049224421382, 0.000997226685286, 0.0235599577427,
					0.0834978371859, 0.102548956871, 0.0711819678545,
					0.036801636219, 0.0450360774994, 0.0746346488595,
					0.0444390587509, -0.0449501536787, -0.118805274367,
					-0.0695127546787, 0.0448371134698, 0.0487337596714,
					-0.0660304650664, -0.0670138671994, 0.00424253102392,
					-0.0062251938507, -0.029847053811, -0.0352139919996,
					-0.0455670654774, -0.0615036934614, -0.0382020622492,
					-0.0471493899822, -0.0647716224194, 0.00328353489749,
					0.00453815050423, -0.0570790022612, -0.0229996610433,
					0.0448121801019, 0.0113733215258, -0.0935406386852,
					-0.0607004836202, 0.0381292104721, 0.0239018015563,
					-0.00151262572035, 0.0570696257055, 0.128285244107,
					0.0460687838495, -0.0770548731089, -0.0125086214393,
					0.141804531217, 0.196668639779, 0.193487539887,
					0.186582177877, 0.161091521382, 0.0511468723416,
					-0.0483444780111, -0.0275491662323, 0.00422272505239,
					0.0229241792113, 0.0551587417722, 0.0864676311612,
					0.0164900608361, -0.0733436346054, -0.0315476730466,
					0.0208105295897, -0.00231199059635, -0.0294342096895,
					0.00433521298692, 0.038351316005, -0.00576201081276,
					-0.0177770797163, -0.00579060427845, -0.0149333700538,
					0.00132234208286, -0.00290770130232, 0.00759176257998,
					0.0126122217625, 0.0273298677057, 0.105200394988,
					0.0736077055335, -0.00639535300434, 0.0197822637856,
					0.00670975632966, -0.0565457642078, -0.0495964698493,
					0.0375795178115, 0.0471276268363, 0.019343316555,
					0.0167414788157, 0.0145383030176, 0.0795258134604,
					0.0966645851731, 0.0862726196647, 0.132216900587,
					0.104273751378, 0.00855508260429, -0.0132974414155,
					0.00350645254366, 0.0450989082456, 0.102802604437,
					0.0492262542248, -0.0770645588636, -0.09231556952,
					0.00666317716241, 0.0214644521475, -0.0269584525377,
					-0.0252336282283, -0.0440839976072, -0.0664809569716,
					-0.0122024398297, 0.0833839178085, 0.126417562366,
					0.107286706567, 0.0488761365414, -0.0790465474129,
					-0.120619051158, -0.0328205861151, -0.0289913546294,
					-0.0665975511074, -0.0698144733906, -0.022329904139,
					0.0757676586509, 0.115389734507, 0.107959397137,
					0.0694053247571, 0.063435472548, 0.102954670787,
					0.0516104176641, 0.0418086312711, 0.134171977639,
					0.11820499599, 0.0169494487345, -0.0132964234799,
					-0.0211206004024, -0.0469739958644, -0.0123134385794,
					0.0465517938137, 0.0607624053955, 0.0923330038786,
					0.0895831808448, 0.0186581909657, -0.00621281564236,
					0.0672145485878, 0.136592403054, 0.0990167856216,
					0.0645249933004, -9.98230243567e-05, -0.0955129042268,
					-0.0410910360515, 0.0587469637394, 0.0646819993854,
					0.0366474352777, 0.0292086862028, 0.0897339880466,
					0.150427654386, 0.116574749351, 0.0662097409368,
					0.0194404497743, -0.0475637018681, 0.00318071222864,
					0.124052077532, 0.121229894459, -0.00782205350697,
					-0.0802838355303, 0.0422440841794, 0.132577240467,
					0.106843568385, 0.104550532997, 0.0593299493194,
					0.000451103900559, -0.0186303518713, -0.00816928129643,
					0.0600396133959, 0.0866977125406, 0.0476515516639,
					0.0144071467221, 0.0653410255909, 0.162813723087,
					0.150082945824, 0.0961449444294, 0.0590231083333,
					0.0495596528053, 0.0804815292358, 0.057965438813,
					0.0202055573463, 0.00897512119263, -0.0327474959195,
					-0.0657151415944, -0.00191221339628, 0.0863461345434,
					0.095508992672, 0.0759624540806, 0.056705031544,
					0.0718206390738, 0.101799458265, 0.0358597896993,
					-0.0994958803058, -0.120514497161, -0.0235645547509,
					0.0251779127866, 0.045637845993, 0.0969352573156,
					0.12010525912, 0.110705681145, 0.102767415345,
					0.0942346602678, 0.152950048447, 0.204854696989,
					0.139119163156, 0.0415665842593, -0.0147249167785,
					0.00926640629768, 0.0296550430357, -0.0108926566318,
					-0.0749840438366, -0.11902204901, -0.0440751574934,
					0.00980514474213, -0.069638364017, -0.0940884202719,
					-0.0244156178087, 0.0604714304209, 0.069380633533,
					-0.00969492085278, -0.0860753804445, -0.131615355611,
					-0.0518118143082, 0.0536928139627, 0.0113861132413,
					-0.0488383024931, -0.0446432977915, -0.00286771194078,
					0.0235502962023, 0.0247257724404, 0.0424511581659,
					0.0519916638732, 0.0185424312949, -0.0342005677521,
					-0.0647074431181, -0.0413885191083, -0.0180633589625,
					-0.0243624132127, 0.023208104074, 0.0933032780886,
					0.122518993914, 0.088548541069, 0.0308380480856,
					0.0587475299835, 0.0966880023479, 0.0903340280056,
					0.0884257555008, 0.0350057594478, 0.00975521374494,
					0.0102651566267, -0.054493740201, -0.0160387922078,
					0.119276642799, 0.168668657541, 0.164329692721,
					0.15389610827, 0.0432487241924, -0.00815139524639,
					0.0909954458475, 0.0541935451329, -0.0435257740319,
					-0.0158971138299, -0.00940556358546, -0.0560466423631,
					-0.0133261559531, 0.0544630028307, 0.066938765347,
					0.0754457190633, 0.127985194325, 0.0359379723668,
					-0.159846335649, -0.142248809338, -0.0896682441235,
					-0.11607927084, -0.0621843710542, -0.0251403171569,
					-0.0201512277126, 0.009980622679, 0.0290444158018,
					0.00896810553968, 0.0391854122281, 0.104036182165,
					0.0776745975018, 0.0247566625476, 0.000214475017856,
					-0.00234556733631, 0.00297519844025, 0.0129536688328,
					-0.039594233036, -0.0946422815323, -0.108042426407,
					-0.103074342012, -0.0615524798632, 0.0249700825661,
					0.122101530433, 0.127411097288, 0.0509272553027,
					-0.0107639087364, -0.0293478183448, -0.0504259094596,
					-0.0026651143562, 0.0649214163423, 0.014806875959,
					-0.0246660131961, 0.044321924448, 0.124590560794,
					0.088162407279, -0.0160891171545, -0.0438851192594,
					-0.0351708233356, -0.10162076354, -0.0689676105976,
					0.102918297052, 0.129837453365, 0.0484102889895,
					0.043798353523, 0.0370022691786, 0.0172782707959,
					0.00305283931084, 0.0273962058127, 0.145066544414,
					0.132290825248, 0.0233044922352, 0.0721642971039,
					0.045673776418, -0.0690113604069, -0.0608007982373,
					-0.042797010392, -0.038568072021, -0.0380978286266,
					-0.0188845023513, 0.0451949313283, 0.0606407746673,
					-0.000604449945968, -0.036123983562, -0.0434788987041,
					-0.0227278862149, 0.0447512939572, 0.0278423950076,
					-0.0202082507312, 0.0338347032666, 0.0523778833449,
					0.0303164720535, 0.0454800538719, 0.0422134809196,
					0.0019372748211, -0.0450382418931, -0.0681816637516,
					-0.0725440606475, -0.0437388941646, -0.0190392453223,
					0.0183761976659, 0.0423672385514, 0.00154779711738,
					0.0340738259256, 0.0832092761993, 0.0280876718462,
					-0.0531140379608, -0.0358592048287, 0.0497926063836,
					0.0404812842607, 0.00261818408035, -0.0120615251362,
					-0.049834549427, -0.0164324026555, 0.0170627031475,
					-0.00448248162866, 0.0173219833523, 0.0779000520706,
					0.0762844160199, -0.0182065330446, -0.0893061459064,
					-0.0892427489161, -0.0579600073397, 0.0448080077767,
					0.162659436464, 0.159938693047, 0.114478699863,
					0.100418739021, 0.0763065963984, 0.0214323475957,
					-0.0455327704549, -0.0563854761422, 0.0115841804072,
					0.0410139709711, -0.0222403351218, -0.0385817959905,
					0.00180456845555, -0.00685427384451, -0.0545721426606,
					-0.0208184421062, 0.0700703561306, 0.0366923063993,
					-0.0315891802311, -0.0183831043541, -0.0112593909726,
					-0.00715702725574, 0.0471850708127, 0.0625094696879,
					0.0983488932252, 0.13807836175, 0.0261067580432,
					-0.046534832567, -0.00545604620129, 0.0184976905584,
					0.0186101980507, 0.038871448487, 0.067178465426,
					0.0970300287008, 0.108351111412, 0.0387036092579,
					-0.0301955416799, -0.050675265491, -0.0400119312108,
					0.0409230291843, 0.0805814936757, 0.0506633222103,
					0.0611262358725, 0.0730799287558, 0.0888042449951,
					0.10699544847, 0.0540954209864, 0.0148555077612,
					0.0640918835998, 0.0693275630474, 0.00664261635393,
					-0.00695126783103, 0.0417090058327, 0.099534407258,
					0.114921167493, 0.0857462063432, 0.0566861405969,
					0.00202259235084, -0.0498150140047, -0.0427732430398,
					-0.0280704516917, -0.0716600641608, -0.136701136827,
					-0.0695882588625, 0.027802541852, 0.0034649122972,
					-0.0436432436109, -0.0523905158043, -0.0461381711066,
					-0.0508800707757, -0.00438386574388, 0.051057819277,
					0.0264852158725, -0.0282409600914, -0.0543118789792,
					0.0329628176987, 0.0895302370191, 0.0309008341283,
					0.00623638927937, 0.00840633083135, -0.00619508791715,
					-0.0447425022721, -0.0620762854815, -0.035102583468,
					-0.0147933745757, 0.0202472489327, -0.0144064528868,
					-0.0658537223935, -0.0180601458997, 0.0206575263292,
					0.0173863098025, 0.0325393341482, 0.0261221081018,
					-0.00229556160048, 0.029325960204, 0.0474188327789,
					0.0206835828722, 0.025285018608, 0.018399970606,
					0.0134383961558, 0.0712894499302, 0.10353282094,
					0.0903684720397, 0.0599754266441, 0.0880104228854,
					0.0969524756074, 0.0336305387318, 0.0310386829078,
					0.0649082362652, 0.0222569983453, -0.0829236879945,
					-0.127257168293, -0.0894322916865, -0.0290556810796,
					0.00189419696108, -0.0209887158126, -0.0227242875844,
					0.0382883101702, 0.0734232440591, 0.0666011720896,
					-0.00595274008811, -0.0187158528715, 0.0410508699715,
					0.00225861789659, -0.0234831664711, 0.0300750415772,
					0.0775850117207, 0.0698858574033, 0.0248777959496,
					-0.0275238081813, -0.0134964762256, 0.0677632391453,
					0.0510828867555, -0.00850708037615, 0.00826077722013,
					0.00673715770245, 0.00478036142886, 0.0659095495939,
					0.0705509781837, 0.0300072301179, 0.0396294891834,
					0.0434588566422, 0.00316748442128, 0.0255270581692,
					0.0970338657498, 0.0457727685571, -0.01441950351,
					0.0275120977312, 0.0468018576503, 0.0193686187267,
					0.0262653790414, 0.0888657271862, 0.0976708382368,
					0.0154698006809, -0.0150876361877, 0.0109730148688,
					0.00456143403426, -0.0361845418811, -0.0491180568933,
					-0.0661330521107, 0.0163627993315, 0.161509379745,
					0.140555083752, 0.000120840370073, -0.092068746686,
					-0.0382276959717, -0.00887840520591, -0.0675976201892,
					-0.055404856801, 0.0688825473189, 0.101355999708,
					-0.0183458123356, -0.0812829658389, -0.0143519975245,
					0.0618491247296, 0.0510673932731, 0.0588979944587,
					0.0825804024935, 0.0291334986687, -0.0477057471871,
					-0.121076188982, -0.109600275755, -0.0239059142768,
					-0.0488633811474, -0.111265048385, -0.054299492389,
					0.0342962741852, 0.0587263777852, 0.0290523935109,
					0.0440911576152, 0.0722541362047, 0.029603227973,
					-0.00335435988382, -0.0532379709184, -0.0634855628014,
					-0.0357929244637, -0.0365512855351, 0.0107522774488,
					0.0570545047522, 0.0878785699606, 0.0288843903691,
					-0.0761008858681, -0.0824108570814, -0.0584009587765,
					-0.0353985354304, -0.0353228896856, -0.00765363918617,
					0.0193396508694, -0.0315497778356, -0.0294191967696,
					0.0278920698911, 0.019670471549, -0.0372490361333,
					-0.0159332603216, 0.0226298235357, -0.0521992705762,
					-0.129296466708, -0.0963747873902, -0.00443518068641,
					0.0332486927509, -0.00149398087524, 0.00131736975163,
					0.00938455108553, -0.0236922428012, -0.00678351335227,
					0.070034198463, 0.0827769786119, -0.00437654741108,
					-0.0429664477706, -0.034018009901, 0.00624725827947,
					0.0966883003712, 0.138703122735, 0.0662883073092,
					-0.0465361922979, -0.0886357575655, -0.0748026520014,
					-0.0110220024362, 0.0320101454854, -0.00469110812992,
					-0.00665135867894, 0.0554169155657, 0.104248680174,
					0.0800745338202, 0.0527402460575, 0.067891292274,
					0.00707401847467, -0.070421487093, -0.0667296051979,
					-0.0492842160165, 0.0224620494992, 0.106562614441,
					0.0787607431412, 0.0278783198446, 0.0163821894675,
					-0.0297512896359, -0.0499642081559, 0.00343549484387,
					0.0698558539152, 0.0672489032149, 0.00829496327788,
					-0.0414633005857, 0.012509373948, 0.064731657505,
					-0.0747666433454, -0.105227276683, 0.00843125302345,
					0.054492264986, 0.07311771065, 0.0627341270447,
					-0.00167936086655, -0.0497814267874, -0.0188341513276,
					0.0425883606076, 0.0568603165448, -0.0177366808057,
					-0.0310033001006, 0.0299023743719, 0.005640713498,
					0.00350868538953, 0.0735539570451, 0.0891410931945,
					0.0327857770026, -0.0246805846691, -0.0309137292206,
					-0.0547738149762, -0.0534077771008, 0.0294661670923,
					0.0823915600777, 0.050061032176, -0.00195911619812,
					0.00265267188661, -0.0123045872897, -0.0237464550883,
					0.0113986814395, 0.0544326715171, 0.0484499745071,
					0.0104017471895, -0.0237646792084, -0.132974669337,
					-0.155550926924, -0.0102709829807, 0.0655699819326,
					0.0365173369646, 0.0271107833833, 0.0329690761864,
					0.0174720007926, 0.0141047090292, 0.0411207266152,
					0.0864626169205, 0.0268727354705, -0.0726897567511,
					-0.0461411178112, 0.049036540091, 0.141921907663,
					0.0955696851015, -0.025036431849, -0.0464393161237,
					-0.0594973154366, -0.061658129096, 0.00622764509171,
					0.0692072510719, 0.069789968431, -0.00734979053959,
					-0.0801065117121, -0.063678689301, -0.00489205494523,
					0.0552208907902, 0.102094821632, 0.0891422182322,
					0.0752622932196, 0.0566540583968, -0.0419360361993,
					-0.100936457515, -0.0617809966207, -0.0185690894723,
					0.0202943608165, 0.0373545736074, 0.0048485789448,
					-0.0361721664667, -0.000793833751231, 0.0361053235829,
					0.0292746275663, 0.0758018195629, 0.0490338131785,
					-0.0300664752722, -0.0145443677902, 0.0467800498009,
					0.0825066268444, 0.0558641925454, -0.0121036404744,
					-0.0268347002566, -0.0107092550024, -0.0487873516977,
					-0.0254845824093, 0.0826069787145, 0.0657129138708,
					0.0101053100079, 0.0371510386467, -0.0257453620434,
					-0.0381532087922, 0.0402947962284, 0.0372960194945,
					-0.00368731329218, -0.0518725663424, -0.0365640185773,
					-0.00651924451813, 0.00200844323263, 0.040441121906,
					0.0207514502108, 0.00381879508495, 0.0229199882597,
					-0.00139433820732, -0.0141098638996, -0.00390368280932,
					-0.0443020239472, -0.128317251801, -0.118449226022,
					-0.00860750488937, 0.0946469157934, 0.0897870138288,
					0.000248702679528, 0.00807806942612, 0.0846603438258,
					0.0632792636752, 0.000317234895192, -0.0239326637238,
					0.012396408245, 0.0481853857636, 0.0454823821783,
					0.0657938122749, 0.0403858795762, -0.00866033602506,
					-0.000728477374651, 0.0186671577394, -0.00530559569597,
					-0.0397898107767, -0.0510514564812, -0.00163308228366,
					0.0432682782412, 0.0421817526221, 0.0612182468176,
					0.0389708392322, 0.0241040438414, 0.109164297581,
					0.0985532701015, -0.0194123927504, -0.0126206595451,
					0.0297799985856, 0.00220445496961, 0.0119750341401,
					0.06161981076, 0.0617432035506, 0.0186346266419,
					0.0100985839963, 0.00694153783843, 0.000557755352929,
					0.020672371611, 0.0762404128909, 0.076321721077,
					0.018744578585, 0.00364783429541, 0.0191757567227,
					0.0146014783531, -0.049197845161, -0.0695689097047,
					-0.0975381582975, -0.0911883935332, 0.0179800614715,
					0.0602229684591, 0.0390420816839, -0.0129019413143,
					-0.100768119097, -0.133110880852, -0.0528891384602,
					1.72044474311e-05, -0.0246544405818, -0.0461472794414,
					0.0113443136215, 0.148150265217, 0.187468841672,
					0.0901870876551, -0.0146392844617, -0.0836224555969,
					-0.0641120225191, -0.0065546524711, -0.0295770633966,
					-0.06471824646, -0.012090661563, 0.0115495873615,
					0.023345194757, 0.115307480097, 0.0890583992004,
					-0.0436702556908, -0.0843829959631, -0.0336742177606,
					0.032778121531, 0.0121465520933, -0.0733811855316,
					-0.0504079796374, 0.0466163903475, 0.103070780635,
					0.0719571337104, 0.0574743300676, 0.116456784308,
					0.0742522254586, -0.0237452592701, 0.0444104447961,
					0.0848579779267, -0.0035048481077, 0.0620540939271,
					0.169008940458, 0.165764123201, 0.139256298542,
					0.117472141981, 0.104710459709, 0.0214905738831,
					-0.0715761333704, -0.0429978966713, 0.0223402455449,
					0.0567678697407, 0.069930061698, 0.0549181550741,
					0.0526015013456, -0.000856614322402, -0.0787886828184,
					-0.0898406505585, -0.0778873413801, 0.0164439566433,
					0.125248908997, 0.0842709764838, 0.00533913541585,
					0.0110720787197, 0.0635074600577, 0.12556360662,
					0.112493738532, -0.00484675355256, -0.0257330946624,
					-0.0011684957426, -0.0101562859491, 0.0448713824153,
					0.0118740703911, -0.0731586739421, -0.0469711609185,
					-0.0199935957789, -0.046956397593, -0.0387738123536,
					0.00034933295683, 0.0246408469975, 0.0246799327433,
					0.00293587590568, -0.0482884123921, -0.0410374067724,
					0.0156658943743, 0.013762419112, 0.0265587568283,
					0.0478872507811, 0.0682781264186, 0.115151710808,
					0.0879118666053, 0.0226862207055, -0.0496606826782,
					-0.0433257520199, 0.033249553293, 0.0530312620103,
					0.0933348536491, 0.144577130675, 0.0985886007547,
					0.0869575738907, 0.103205956519, -0.0125631764531,
					-0.0932881832123, -0.0589824654162, 0.000175428780494,
					-0.0286786220968, -0.109161913395, -0.117995448411,
					-0.0158210769296, 0.0732587575912, 0.0660536363721,
					0.105547130108, 0.130781173706, 0.119295120239,
					0.0875269621611, 0.0414508618414, -0.00192918814719,
					0.00212729535997, 0.0270352177322, -0.0342019498348,
					-0.0260284170508, 0.0400057248771, -0.0240091942251,
					-0.103532135487, -0.0566543638706, -0.00198532338254,
					-0.00233380962163, 0.0401715971529, 0.0552266463637,
					-0.0383894443512, -0.0491546057165, -0.00394717091694,
					-0.00465866364539, 0.0188081208616, 0.0440551750362,
					0.0492175370455, 0.0746133103967, 0.0955356508493,
					0.0189167987555, -0.0570641644299, -0.0571392923594,
					-0.0405230410397, -0.00142493983731, -0.0396096259356,
					-0.143215194345, -0.142307087779, -0.0941622108221,
					-0.044711150229, -0.0371835827827, -0.0928390473127,
					-0.141985401511, -0.132346332073, -0.0384812131524,
					0.0181875154376, -0.0158567912877, -0.0192294977605,
					0.0165208652616, 0.0135600082576, 0.0255265999585,
					0.00444200774655, -0.00808800105006, 0.0591189190745,
					0.0583397224545, -0.0283496640623, -0.078078366816,
					-0.101729914546, -0.0640662759542, 0.0447979345918,
					0.0220281649381, -0.0414779409766, 0.00599828455597,
					0.0235291235149, 0.0262943431735, 0.0720885396004,
					0.0611358731985, 0.00572004448622, -0.011731442064,
					0.0454044304788, 0.116401873529, 0.0898225009441,
					-0.00349216838367, -0.12196418643, -0.103634133935,
					-0.018673337996, -0.0851835012436, -0.133616521955,
					-0.079318664968, -0.00739516923204, 0.0072272978723,
					-0.0030474786181, -0.000757608446293, -0.0283523667604,
					-0.0335091426969, -0.000784713542089, 0.0339319780469,
					0.0572518482804, -0.0100394850597, -0.0988019183278,
					-0.0239980425686, 0.0592648200691, 0.0224057361484,
					-0.0761368572712, -0.158468857408, -0.119665533304,
					-0.0693922266364, -0.0238041244447, 0.0121736908332,
					-0.0228407271206, -0.121559485793, -0.132575765252,
					0.00216276478022, 0.0720190703869, 0.0380743704736,
					0.0280009973794, 0.149629980326, 0.191968202591,
					0.0305238459259, -0.0875358656049, -0.083400323987,
					-0.0269411988556, 0.0221795570105, 0.0347126238048,
					0.0324065946043, 0.0135308988392, 0.0368426851928,
					0.0386006981134, 0.00424071960151, -0.0376388691366,
					-0.031019711867, 0.00481734098867, -0.0155980419368,
					-0.0302739050239, -0.0199269894511, 0.0382899455726,
					0.0539419613779, 0.0360530130565, 0.104645259678,
					0.0886655971408, -0.0493440926075, -0.0540114268661,
					0.0266722477973, 0.0506339408457, 0.0614468976855,
					0.0497016385198, 0.00367702543736, -0.0107938628644,
					0.0845870226622, 0.18647326529, 0.114779539406,
					-0.0220122076571, -0.0658434182405, -0.0369523987174,
					0.0396175906062, 0.0853594765067, 0.0251474250108,
					0.00297303963453, 0.0880766957998, 0.0698642283678,
					-0.0865081995726, -0.12430422008, -0.0422251597047,
					0.00987718906254, 0.00626296224073, -0.10953310132,
					-0.153379812837, -0.02221416682, 0.0938470363617,
					0.0825079455972, -0.044660769403, -0.062776774168,
					-0.0251694377512, -0.0137517694384, 0.0710016414523,
					0.133001372218, 0.0926728695631, 0.0855570882559,
					0.136173829436, 0.143769443035, 0.114264443517,
					0.0409016907215, -0.0100287124515, 0.00699259433895,
					0.0544609203935, 0.100775539875, 0.0939111560583,
					0.0680590867996, 0.042965747416, -0.0239370558411,
					-0.00362632679753, 0.0953690260649, 0.13427400589,
					0.120042525232, 0.071200452745, 0.0120267905295,
					-0.0510813444853, -0.0727582871914, -0.0292317215353,
					-0.0622165612876, -0.0447961837053, 0.0684974491596,
					0.138211593032, 0.137762650847, 0.0386548340321,
					0.0085145290941, 0.0397126562893, 0.0196999534965,
					-0.0623400099576, -0.0875898748636, -0.0311550199986,
					-0.0173069052398, -0.0432282872498, -0.0447854585946,
					0.060771998018, 0.093929246068, -0.0192946605384,
					-0.0815483108163, -0.0733856484294, -0.0586927160621,
					-0.0433199629188, -0.0171768143773, 0.0227085910738,
					0.0781637877226, 0.112572170794, 0.0795457884669,
					0.0261403415352, 0.00875758379698, 0.0180306136608,
					0.0198631063104, 0.00249168346636, -0.036243584007,
					-0.0458164550364, -0.0542229264975, -0.139564365149,
					-0.141502544284, 0.0214142166078, 0.0641421154141,
					0.0150607582182, 0.0641901344061, 0.114542931318,
					0.14906771481, 0.0878768265247, -0.0370347946882,
					0.0227411203086, 0.195074558258, 0.19193610549,
					0.064951248467, 0.0114353541285, 0.0103500746191,
					0.0207346230745, 0.0445783808827, 0.0316847264767,
					0.00312026683241, -0.00343118584715, 0.000151104788529,
					0.0243352092803, 0.0339320339262, -0.0127037074417,
					-0.13841226697, -0.143908128142, -0.0404806062579,
					-0.0471947528422, -0.0805599987507, -0.0340012982488,
					0.00230954238214, -0.0286409426481, -0.0399144664407,
					-0.0758228749037, -0.121681854129, -0.0393518283963,
					0.0618276707828, 0.0304812379181, -0.0327299498022,
					0.00143819721416, 0.0524553433061, 0.0698146820068,
					0.0807100385427, 0.0724861770868, 0.104209423065,
					0.112686671317, 0.0750368312001, 0.0578128322959,
					0.0434401072562, 0.0362542234361, -0.0244609918445,
					-0.152225479484, -0.173091217875, -0.0883067324758,
					-0.0318004861474, 0.0157414693385, 0.00442175008357,
					-0.0322506912053, -0.0789935961366, -0.0987362191081,
					-0.0615653991699, -0.0384409166873, -0.00298451725394,
					0.0014479404781, 0.0182559005916, 0.0247869994491,
					0.0129451649264, 0.0304324515164, 0.0253072306514,
					-0.0501378923655, -0.122722305357, -0.095858335495,
					-0.00179098907392, 0.107261896133, 0.129359140992,
					0.0669774115086, 0.0423459261656, 0.0425442904234,
					-0.0159162469208, -0.00598034355789, 0.0662070736289,
					0.0757259726524, 0.0820893645287, 0.119134798646,
					0.0771923214197, -0.00929221604019, -0.0030711570289,
					-0.0247509479523, -0.067051127553, 0.0371106639504,
					0.171703338623, 0.151657879353, 0.0137032559142,
					-0.0603148005903, -0.097256757319, -0.191284239292,
					-0.19198551774, -0.131988883018, -0.0669940263033,
					0.0214947611094, -0.0305208172649, -0.0914465710521,
					0.0307394973934, 0.161243259907, 0.169746294618,
					0.0782351270318, -0.0319763049483, -0.0174169950187,
					0.0600865334272, 0.0768877863884, 0.073191717267,
					0.0672702863812, 0.0417068004608, -0.0648893341422,
					-0.0600465200841, 0.0479982718825, -0.00791554059833,
					-0.0759866163135, -0.0547723248601, -0.0311345327646,
					-0.00784083455801, 0.0172685626894, 0.04998883605,
					0.0318264141679, -0.000173969805473, 0.0138536859304,
					0.0333149470389, 0.0718671530485, 0.106977954507,
					0.126236125827, 0.0840149000287, 0.00406524352729,
					-0.00484480056912, 0.0328538529575, -0.00757092516869,
					-0.0125604514033, 0.097131729126, 0.0680055916309,
					-0.0102803949267, 0.0273194741458, 0.0111243743449,
					-0.00255148112774, 0.0276047587395, -0.034113291651,
					-0.105137214065, -0.0415620431304, 0.0244647935033,
					0.0253033451736, 0.0303371790797, -0.0145102674142,
					0.013379752636, 0.0788753777742, 0.028936214745,
					-0.0551003217697, -0.0995192378759, -0.0568394325674,
					-0.00192920700647, -0.0235082060099, -0.0435166284442,
					0.02031124942, 0.0321931764483, -0.0401857420802,
					-0.054935850203, -0.0542970299721, -0.0483850389719,
					-0.00627635745332, -0.0118802627549, -0.0435782037675,
					-0.0300360564142, -0.0266223996878, -0.0269448962063,
					-0.0151832532138, 0.00666226772591, 0.0209244117141,
					0.0340731590986, 0.0284139532596, -0.0331871956587,
					-0.115916758776, -0.110388666391, -0.0183286648244,
					0.000409536878578, -0.0116989128292, 0.0529805347323,
					0.0599170923233, 0.0388343781233, 0.0437624156475,
					-0.0386564321816, -0.0289622880518, 0.0872651338577,
					0.0478997379541, -0.0680584311485, -0.0627975985408,
					0.00929157994688, 0.0148276817054, 0.0057234633714,
					0.0743082985282, 0.110520601273, 0.056812055409,
					0.0166068095714, 0.031486235559, 0.0540384352207,
					0.0223697051406, -0.0159254595637, 0.0436748601496,
					0.125822722912, 0.122160181403, 0.0305801182985,
					-0.044585518539, -0.0448461845517, -0.0561575144529,
					-0.0353582501411, 0.0567516162992, 0.125308066607,
					0.0589368492365, -0.0416973307729, 0.0104366345331,
					0.0586039274931, 0.00203584157862, -0.00811620987952,
					0.0286024846137, 0.0361067838967, 0.070771150291,
					0.019019221887, -0.100408039987, -0.0957619026303,
					0.00649952050298, 0.0749139934778, 0.0506133250892,
					0.024538423866, -0.0043887058273, -0.0170118827373,
					0.0408249050379, 0.0610031038523, 0.060478463769,
					0.0905512720346, 0.0699268430471, 0.01308317855,
					-0.0333560705185, -0.058815497905, -0.0628225132823,
					-0.0441142506897, 0.00859581679106, 0.0315163880587,
					-0.00110670609865, -0.0533677823842, -0.0296901836991,
					-0.0247270688415, -0.0786829441786, -0.0055901678279,
					0.0723019018769, 0.0243876893073, 0.0207791849971,
					0.0726155117154, 0.0919737070799, 0.120761953294,
					0.116023957729, 0.0557713545859, 0.0306610185653,
					0.0480432659388, 0.0488136671484, 0.0106818173081,
					-0.0515228845179, -0.0458149202168, 0.0118316626176,
					0.0195907726884, 0.0652401819825, 0.110745936632,
					0.046139691025, -0.0527577102184, -0.091895788908,
					-0.0268553160131, -0.0228330157697, 0.00309806875885,
					0.117210760713, 0.10649767518, 0.0347563661635,
					0.0395027957857, 0.0658549517393, 0.0293192435056,
					0.00535714626312, -0.0375834256411, -0.0949669629335,
					-0.0559992864728, -0.020390290767, -0.0385123044252,
					-0.0386651009321, 0.00494511751458, 0.0724838450551,
					0.0431768409908, -0.0656409859657, -0.0376867726445,
					0.0526678711176, 0.0248417928815, -0.00676136417314,
					0.0398609004915, 0.0531167685986, -0.0132844429463,
					-0.0399797707796, 0.025461351499, 0.0464649349451,
					0.0050947740674, 0.00670849392191, 0.0310314297676,
					-0.00678518787026, -0.122047945857, -0.169437691569,
					-0.038977779448, 0.0834347978234, 0.0645817220211,
					0.088033914566, 0.158421173692, 0.0904550552368,
					-0.0611982047558, -0.0702064186335, -0.0130742490292,
					-0.00213543977588, 0.0185191482306, -0.0445856116712,
					-0.0636395737529, 0.0899356901646, 0.188894629478,
					0.1328381598, 0.00237148860469, -0.104855328798,
					-0.0651165693998, 0.00305403256789, -0.0202032700181,
					-0.0464168563485, -0.023211857304, 0.0307231247425,
					0.0363735333085, 0.062865100801, 0.110258743167,
					0.0468598380685, 0.0070859468542, 0.01287490502,
					-0.0314185656607, -0.00559508847073, 0.0622163303196,
					0.0462134107947, 0.0515369772911, 0.0897413343191,
					0.0807551145554, 0.0219324436039, -0.0756020769477,
					-0.119174927473, -0.0978782325983, -0.0425877794623,
					-0.045746922493, -0.0773562192917, -0.00548352720216,
					0.0409216471016, 0.0723115354776, 0.0963732153177,
					0.00930813979357, -0.016040943563, 0.0868087187409,
					0.124017506838, 0.0886342823505, 0.0345379263163,
					-0.0437390059233, -0.0879284068942, -0.0557413250208,
					-0.0109383482486, -0.0643731579185, -0.129050254822,
					-0.0583066232502, 0.0190501827747, -0.0346270576119,
					-0.0989420562983, -0.0515061281621, 0.0117942886427,
					0.0121388724074, 0.0122674191371, -0.0222392771393,
					-0.0749264359474, -0.03429678455, 0.0106137348339,
					-0.0341657102108, -0.0334504321218, 0.043203830719,
					0.0734851285815, 0.0596756637096, 0.054068621248,
					0.0407810285687, 0.0630174800754, 0.0464608483016,
					-0.0723429396749, -0.115722410381, -0.0083856517449,
					0.075179733336, 0.0501845367253, -0.0260302443057,
					-0.0835777074099, 0.00205239816569, 0.0736816823483,
					-0.0367428436875, -0.122237198055, -0.0564948916435,
					0.00553465867415, 0.00511313695461, 0.0580741427839,
					0.0721095651388, 0.0297461524606, 0.0289144441485,
					0.0655199438334, 0.152176111937, 0.172732755542,
					0.0917783528566, -0.0511567667127, -0.1513466537,
					-0.0834037512541, -0.00825198553503, 0.0448019467294,
					0.0754869878292, 0.00632843701169, -0.0122916158289,
					0.00733389519155, -0.0122397346422, -0.00455502374098,
					0.018491556868, 0.0156301576644, -0.0472969263792,
					-0.0824985355139, -0.0138113535941, 0.0440222546458,
					-0.00762707646936, -0.106429696083, -0.0916351824999,
					-0.00851945858449, 0.0131931854412, 0.0327845774591,
					0.133541345596, 0.143301710486, 0.0361180640757,
					-0.0159947704524, 0.0127354171127, 0.0490559823811,
					0.00568196736276, -0.00321738678031, 0.010885020718,
					-0.0332530327141, -0.066403105855, -0.134967878461,
					-0.146753951907, -0.000856794591527, 0.128149449825,
					0.0976778194308, 0.0466487370431, 0.0129064936191,
					-0.0604856610298, -0.0223735459149, 0.0664988607168,
					0.0470193326473, -0.00869298260659, 0.0296849589795,
					0.0317127034068, -0.0681065320969, -0.0435181260109,
					0.108255565166, 0.136398747563, 0.0463881380856,
					0.0166874174029, -0.026850502938, -0.0501672588289,
					-0.00199886062182, 0.0361393801868, 0.0931349247694,
					0.120511613786, 0.0830072239041, 0.0542876087129,
					0.0204924792051, -0.0157364085317, -0.0175720211118,
					0.0255657620728, 0.0678225159645, 0.0360114574432,
					-0.0176975540817, -0.0350202955306, -0.0566621944308,
					-0.0945769250393, -0.127587601542, -0.0885099172592,
					-0.024022700265, -0.0132075119764, -0.00413925340399,
					0.00901830941439, -0.0165962483734, -0.0464847907424,
					0.00887741334736, 0.0455786511302, 0.074747569859,
					0.0483483374119, -0.00666143465787, 0.0645155012608,
					0.0959842503071, 0.000757130852435, -0.07460026443,
					-0.0187783651054, 0.0206344164908, -0.0814288035035,
					-0.165933355689, -0.073003411293, 0.040418818593,
					0.00435012485832, -0.00781829003245, -0.00701385969296,
					-0.0773856118321, -0.0617632605135, -0.0288592986763,
					-0.0128795253113, 0.0372086800635, 0.0480633415282,
					0.0449492484331, 0.0202951952815, 0.0122120035812,
					0.0679752677679, 0.0523331202567, 0.0369086526334,
					0.0869616866112, 0.0414937734604, 0.00514115719125,
					0.0080156493932, -0.0260826535523, -0.00546571332961,
					-0.0151901170611, -0.016604129225, 0.0342509299517,
					0.0178479198366, -0.00470364606008, 0.0131616042927,
					0.0203442014754, 0.00306022632867, -0.04562304914,
					-0.0836240202188, -0.0809780657291, -0.0292280912399,
					0.0247225817293, -0.015939924866, -0.0632802173495,
					-0.0479440949857, -0.0424924083054, -0.0610891766846,
					-0.0191991068423, 0.061440974474, 0.0864800140262,
					0.0388620756567, -0.0239711739123, -0.00496980827302,
					0.0360926091671, 0.0558078363538, 0.0731065943837,
					0.0513217039406, 0.010377522558, -0.0115214511752,
					-0.00737514160573, 0.00993760116398, 0.00493823643774,
					0.00143514433876, 0.0603693686426, 0.0678942501545,
					-0.0373771712184, -0.0577019937336, -0.0155541338027,
					0.00332485162653, -0.0349575579166, -0.135156571865,
					-0.152006566525, -0.0877030268312, -0.0334508344531,
					0.0165412463248, 0.101970054209, 0.129176959395,
					0.0462778620422, 0.00519389472902, 0.0185186713934,
					-0.00215247785673, 0.0260551460087, 0.0403539985418,
					0.013783864677, 0.0251647625118, -0.00182826537639,
					-0.0798359662294, -0.0782474055886, -0.006227591075,
					0.0730859190226, 0.202591493726, 0.217901006341,
					0.0935409516096, 0.00866517331451, -0.0207138583064,
					0.034508690238, 0.0521211661398, -0.0347433388233,
					-0.0138688506559, 0.0473279207945, 0.0136235309765,
					0.00436618924141, 0.0213472377509, 0.0144796641544,
					0.0118415094912, 0.0333018377423, 0.0653758496046,
					0.112990967929, 0.121089957654, 0.0475492887199,
					-0.0380155518651, -0.00566466152668, 0.0869261100888,
					0.142131835222, 0.162724539638, 0.0804452449083,
					0.0546862967312, 0.126016870141, 0.114771984518,
					0.0142711028457, -0.0414742380381, 0.0149219213054,
					0.058431006968, 0.0765655115247, 0.0356120206416,
					-0.0453048013151, 0.0133650982752, 0.0431299880147,
					-0.0310330502689, -0.0500068515539, -0.0822813510895,
					-0.109948202968, -0.0889576524496, -0.0126663390547,
					0.0457240454853, 0.0112512419, -0.0169136207551,
					-0.0553695037961, -0.0520759411156, -0.0277520176023,
					-0.0164140518755, 0.0104455128312, -0.0367600880563,
					-0.0318070761859, 0.0247120130807, 0.0233662836254,
					0.00952250696719, -0.0209220983088, -0.0301816873252,
					-0.00267747184262, 0.0918076559901, 0.187779724598,
					0.114708870649, 0.0478880032897, 0.0826578885317,
					0.0603757761419, 0.00976015720516, 0.0160530973226,
					0.0466431602836, 0.0450431257486, 0.0500676631927,
					0.0419810377061, 0.0498580895364, 0.0508061125875,
					-0.0184356775135, -0.0381808243692, 0.028403699398,
					0.0711154863238, 0.00218987022527, -0.0488448552787,
					0.00307225272991, 0.0655489116907, 0.0741073936224,
					0.0179805867374, -0.015909222886, -0.0298609435558,
					-0.0101425461471, 0.0451149605215, 0.0156849808991,
					-0.0066078370437, -0.0012807775056, -0.00948229338974,
					0.0167923532426, 0.0088197151199, -0.0237355288118,
					-0.0284445211291, -0.0233808998019, 0.0590275190771,
					0.0948014110327, -0.0218890234828, -0.0664601027966,
					-0.00587884290144, 0.0223553534597, 0.0515212863684,
					0.0835988670588, 0.0745142921805, 0.0191808640957,
					-0.0278274863958, -0.0339182391763, -0.0483042672276,
					0.0511866733432, 0.146537527442, 0.0659780725837,
					0.0169493556023, 0.022303564474, 0.0189451668411,
					-0.00255813263357, -0.0156424548477, 0.0353853739798,
					0.10289528966, 0.17260286212, 0.119381323457,
					-0.0301144812256, -0.0439224094152, -0.0704184323549,
					-0.130815237761, -0.0342519655824, 0.05900740996,
					0.0690470486879, 0.0686775669456, 0.0521566346288,
					0.0385041236877, -0.0334149859846, -0.140847221017,
					-0.128439873457, -0.028305536136, 0.01764697209,
					0.00650491984561, 0.00886547937989, -0.00103173125535,
					-0.0535382181406, -0.0941585451365, -0.0976416021585,
					-0.100593790412, -0.063445225358, -0.0318300276995,
					0.0210807863623, 0.0721465200186, 0.0280666146427,
					0.0080903749913, 0.0126403477043, 0.0101527580991,
					0.0519593581557, 0.0690792500973, 0.0113318217918,
					-0.0407892391086, 0.0352753289044, 0.117773719132,
					0.00561863230541, -0.0285252649337, 0.0555044077337,
					-0.00512595986947, -0.0797133594751, -0.056429259479,
					0.0236250720918, 0.0750886797905, 0.0225773751736,
					-0.00243208557367, 0.00652045430616, 0.00666574481875,
					0.0155584691092, -0.00801817886531, -0.0549884848297,
					-0.105430260301, -0.0684600621462, 0.0403518937528,
					0.0865718275309, 0.118642091751, 0.160439774394,
					0.110606238246, 0.0218488648534, 0.00449969153851,
					-0.0198814496398, -0.0708287805319, -0.0753405615687,
					-0.0339542850852, 0.0472848936915, 0.0486452952027,
					0.0301926732063, 0.0525339245796, 0.00357714504935,
					-0.0299032516778, -0.0469975546002, -0.108118802309,
					-0.118735514581, -0.0662160515785, 0.0286417528987,
					0.116737559438, 0.0930203571916, 0.0610104389489,
					0.101045608521, 0.136474430561, 0.0813960283995,
					0.0302907600999, 0.0796711519361, 0.0932528525591,
					0.0633121579885, 0.0360026061535, -0.00361425708979,
					-0.0116290263832, -0.0193636324257, -0.0828698650002,
					-0.0767221972346, -0.0347252860665, -0.047170072794,
					0.0127928070724, 0.0635772272944, 0.0305103976279,
					0.0124974641949, 0.0263471193612, 0.0193606466055,
					-0.0325129069388, -0.0252052303404, 0.0670123547316,
					0.186773717403, 0.17214012146, 0.0510792843997,
					0.0584624670446, 0.141056835651, 0.142317384481,
					0.044982675463, -0.0274706073105, 0.00690238969401,
					0.0594061426818, 0.0455096960068, 0.038951408118,
					0.0503677688539, 0.06446403265, 0.0772703364491,
					0.0556337535381, 0.0379735156894, -0.00945344846696,
					-0.0113629810512, 0.0397199690342, 0.0283882468939,
					0.0330821946263, 0.0279473420233, 0.00871708523482,
					0.00101906911004, -0.0161350667477, -0.0324909985065,
					-0.0481984429061, 0.0444501228631, 0.132949322462,
					0.0730724483728, 0.0146772954613, -0.00292197312228,
					0.0265225693583, 0.105489894748, 0.129830420017,
					0.0799630582333, 0.0304708518088, 0.0457736775279,
					0.0321945697069, 0.00555219408125, 0.0409596860409,
					-0.0171751473099, -0.0512152314186, -0.0206994656473,
					-0.0104855084792, 0.0156685914844, -0.00978527963161,
					0.00133536430076, 0.0546834915876, 0.0577578395605,
					-0.00285374722444, -0.0469164997339, -0.0340870767832,
					-0.0581707805395, -0.0920246690512, -0.10917724669,
					-0.112670049071, -0.0718355104327, -0.0287581272423,
					-0.0431021228433, -0.0729464814067, -0.0829576253891,
					-0.073236644268, -0.0163526069373, -0.0270460620522,
					-0.0968664437532, -0.102372094989, -0.0814335793257,
					-0.076457940042, -0.0369556844234, 0.011006148532,
					0.0263150129467, 0.0426903180778, -0.00860187131912,
					-0.116111502051, -0.0957723781466, 0.0167755149305,
					0.0989174172282, 0.0863829180598, 0.00110120559111,
					0.0151347741485, 0.0352879278362, 0.0310105551034,
					0.0697697624564, 0.121236041188, 0.114660784602,
					0.0685351863503, 0.0737138986588, 0.0377051495016,
					0.0259098690003, 0.110395640135, 0.120360143483,
					0.0503649115562, -0.00482558459044, -0.0382153987885,
					0.0180299188942, 0.161019191146, 0.193890243769,
					0.096942551434, 0.0659604817629, 0.00494826631621,
					-0.0682592988014, 0.00521191162989, 0.0657364949584,
					0.0376460030675, -0.0382570251822, -0.0978861674666,
					-0.0475450605154, -0.00769049953669, 0.00131290743593,
					0.0670893341303, 0.109218172729, 0.05473684147,
					-0.0419825874269, -0.0319701768458, -0.00822304654866,
					-0.0641048252583, -0.0296025052667, 0.0593536272645,
					0.0556092374027, 0.0705196261406, 0.100026130676,
					0.0413647964597, 0.00991244986653, 0.0208281092346,
					0.0443349592388, 0.0975938141346, 0.134413823485,
					0.0881208926439, 0.00853730645031, 0.00128517486155,
					0.0418456867337, 0.0275467354804, -0.0387873649597,
					-0.0817295834422, -0.107446745038, -0.0656686723232,
					-0.00968305487186, -0.0285974424332, -0.0220409762114,
					0.032016210258, 0.0713900998235, 0.0547641478479,
					0.00944331195205, 0.0107446732, 0.0181199926883,
					0.0242614354938, 0.04796865955, 0.0132444091141,
					-0.0724595561624, -0.127461135387, -0.121865287423,
					-0.0496081337333, -0.00329578109086, 0.0260338578373,
					0.0208622571081, -0.0725226998329, -0.0463571771979,
					0.0390339046717, 0.0152049632743, -0.0101363742724,
					0.0370325036347, 0.0325758382678, -0.00750389415771,
					0.0720067620277, 0.160880714655, 0.126477912068,
					0.0375845693052, -0.0366581454873, -0.0742213129997,
					-0.0645182207227, -0.0650544911623, -0.072343789041,
					-0.0434360839427, -0.0677708089352, -0.0993772149086,
					-0.0255397874862, 0.0556495860219, 0.00587415182963,
					-0.062626324594, -0.0235081501305, 0.0526708364487,
					0.0572634711862, -0.047025449574, -0.168637514114,
					-0.207867488265, -0.179398819804, -0.12615865469,
					-0.0393588133156, 0.00116146774963, -0.0482801049948,
					-0.113204188645, -0.0731724947691, -0.0006652045995,
					-0.0165010951459, -0.0269705522805, -0.0306790713221,
					-0.0122111374512, 0.000542137189768, -0.052310526371,
					-0.0406749360263, 0.0421645417809, 0.0407065227628,
					-0.0449275150895, -0.0879807472229, -0.0477452278137,
					0.0262877177447, 0.0750245973468, 0.0220435131341,
					-0.0585622861981, -0.0420945547521, 0.00255727162585,
					-0.0201146602631, -0.0677215382457, -0.0535542182624,
					-0.0720866024494, -0.0519256070256, 0.0355417504907,
					0.011386923492, -0.04309553653, -0.0723811909556,
					-0.0774456858635, -0.0705359280109, -0.0635503828526,
					0.0220843497664, 0.156981527805, 0.18472276628,
					0.0686512067914, 0.0104866363108, 0.0831810683012,
					0.0854313075542, -0.0546358935535, -0.135329052806,
					-0.0746077597141, 0.0561360046268, 0.0992713496089,
					0.0317782722414, -0.00976185593754, -0.0433756001294,
					-0.0624497309327, -0.0609002970159, -0.0605017840862,
					-0.0281751342118, 0.029989907518, 0.0601313598454,
					0.0251319799572, -0.0182352606207, 0.020866625011,
					0.0990602001548, 0.114687338471, 0.0586121454835,
					0.00186148507055, -0.0252185687423, -0.00598621321842,
					0.050342772156, 0.07465018332, 0.0842268019915,
					0.0379882976413, -0.0271498616785, -0.00269464636222,
					0.0101939225569, -0.0361169949174, -0.0489741377532,
					-0.0217477139086, -0.0258951913565, -0.0413342788815,
					0.0468886122108, 0.120971210301, 0.0248053744435,
					-0.0584596991539, -0.0317525453866, 0.0128526445478,
					0.025312718004, -0.0195554941893, -0.0535082630813,
					-0.0554447621107, -0.0595870837569, -0.0335259884596,
					0.0256338436157, 0.0263971239328, -0.0750972777605,
					-0.128473326564, -0.0570716895163, 0.0134090930223,
					0.0689136907458, 0.0546467751265, 0.00545873260126,
					0.0191192924976, 0.00608854414895, -0.00162924069446,
					-0.00906248763204, -0.0217960812151, 0.0221670065075,
					0.0601456463337, 0.076986849308, 0.0416960790753,
					-0.0363865867257, -0.0279255546629, 0.0408431068063,
					0.0425595939159, -0.0447839871049, -0.138766676188,
					-0.193326294422, -0.0797874629498, 0.0416341461241,
					-0.00270405085757, -0.0560074225068, -0.00012172600691,
					0.0901714637876, 0.0465594828129, -0.0370618626475,
					-0.0554032288492, -0.0264598056674, -0.00639475788921,
					0.039033010602, 0.0684033483267, -0.0114335967228,
					-0.0426048859954, 0.0777210369706, 0.154318779707,
					0.0528998114169, 0.0216756947339, 0.089870557189,
					0.0705566182733, 0.0183846838772, 0.0396149158478,
					0.047257207334, -0.00389266619459, 0.0203920863569,
					0.0707093700767, 0.0706993862987, -0.00825756136328,
					-0.108065694571, -0.0924779623747, -0.00506384531036,
					0.0579608790576, 0.0675929784775, 0.0393948666751,
					0.0311921201646, 0.065362200141, 0.0936558023095,
					0.114198729396, 0.0818185210228, 0.0404020473361,
					0.0432128049433, -0.024446811527, -0.0744893327355,
					-0.0207221545279, 0.0292940083891, 0.0580511912704,
					0.0755367875099, 0.0366547554731, -0.0323242247105,
					-0.0636304616928, -0.0331928357482, 0.0505222342908,
					0.0947192683816, 0.0907726660371, 0.0439446978271,
					-0.00566462986171, 0.0180235132575, 0.0552234351635,
					0.0466818921268, 0.0117813507095, 0.00236423593014,
					0.00856998562813, 0.0380574911833, 0.0260605309159,
					-0.0185966845602, -0.0130301397294, -0.0382285118103,
					-0.0164471045136, 0.0325633957982, 0.00724067678675,
					0.0233698450029, 0.0282943584025, -0.0117269204929,
					-0.0267886463553, 0.0152862174436, 0.11481102556,
					0.140130132437, 0.0818581879139, 0.052924990654,
					-0.0213322211057, -0.100086227059, -0.0486819818616,
					0.0158153865486, -0.00624604336917, -0.0513519532979,
					-0.0639362856746, -0.0390583500266, -0.0208189990371,
					0.0225273668766, 0.0803510248661, 0.0441797114909,
					0.00521274376661, -0.0106303952634, -0.042425211519,
					-0.0212935153395, -0.0112244943157, -0.0359588861465,
					-0.077476605773, -0.0739586800337, -0.0332973264158,
					-0.0717002600431, -0.117881163955, -0.0613771937788,
					0.0440362505615, 0.0585532039404, 0.0139559060335,
					0.0285561475903, 0.0453017726541, 0.026050914079,
					0.0577604845166, 0.0676152929664, 0.0675458982587,
					0.0880305767059, 0.00402940716594, -0.0424041002989,
					0.0267837848514, 0.0238704271615, -0.0195572152734,
					0.00325263827108, 0.038065046072, -0.00529804313555,
					-0.0827640369534, -0.106260761619, -0.093221232295,
					-0.0276397243142, 0.0169153716415, 0.0220580864698,
					0.0676098018885, 0.0496339946985, -0.0312699787319,
					0.0271909795702, 0.157689839602, 0.150647386909,
					0.125613078475, 0.136911645532, 0.116353549063,
					0.0633094757795, 0.0523043237627, 0.0423253029585,
					0.0227905139327, 0.0185260828584, -0.0139104928821,
					0.0186681598425, 0.0636616721749, 0.0510121844709,
					0.0883991718292, 0.126459762454, 0.0681720748544,
					0.000688172411174, -0.0702742934227, -0.134828403592,
					-0.0851278826594, 0.024980744347, 0.0132268285379,
					-0.0770459398627, -0.0672946423292, 0.0543677285314,
					0.105834335089, 0.013618465513, -0.0339933857322,
					0.0435645803809, 0.0589642077684, -0.0211738515645,
					-0.0572230108082, -0.0115205636248, 0.0508133769035,
					0.0761635005474, 0.0536597445607, 0.0377976000309,
					-0.0264691635966, -0.082830183208, -0.0326119475067,
					0.000595673569478, 0.0585692599416, 0.105373769999,
					0.0832393020391, 0.0906749740243, 0.134156033397,
					0.0994564890862, -0.0131254447624, -0.0790954381227,
					-0.0991594418883, -0.0466227978468, 0.011883537285,
					0.0120968576521, 0.0296682212502, 0.0269549041986,
					-0.0231685135514, -0.0327332243323, -0.00934348907322,
					-0.0288814418018, -0.0592208653688, -0.0382882766426,
					0.00428351340815, -0.00220750202425, 0.0400600172579,
					0.0834428966045, -0.00844303891063, -0.0453647151589,
					-0.00102263735607, -0.0303618535399, -0.0719826966524,
					-0.111709162593, -0.157413929701, -0.111219070852,
					0.000593334320001, 0.0414374507964, -0.0140922050923,
					-0.0395692810416, 0.0388352833688, 0.0263123754412,
					-0.0404639989138, -0.0033676433377, 0.00795378256589,
					0.0182703845203, 0.0563006401062, 0.0583664141595,
					0.111247807741, 0.148081302643, 0.0837298631668,
					0.0175525601953, -0.0399455018342, -0.0540269203484,
					-0.012175951153, 0.0323205552995, 0.0682624131441,
					0.0779836699367, 0.0706477761269, 0.0385667793453,
					-0.00773794203997, 0.00101250340231, 0.017022985965,
					0.0242253094912, 0.0647974535823, 0.0304062999785,
					-0.0116470754147, 0.0167748425156, -0.0169721450657,
					-0.0513231381774, -0.00554747832939, 0.00660091126338,
					-0.0302386563271, 0.00508634280413, 0.0707221999764,
					0.0662068799138, 0.0450755320489, 0.0416886135936,
					0.04309271276, 0.0495116859674, 0.0749136656523,
					0.0324328355491, -0.0498446524143, -0.0632690563798,
					-0.0205550622195, -0.0148803200573, -0.053920134902,
					-0.0125759765506, 0.0304789803922, 0.00870449841022,
					0.0318292155862, 0.0865771025419, 0.0511552803218,
					-0.0200841352344, -0.0399952344596, -0.0439379960299,
					-0.0210185740143, 0.0157326105982, 0.0518480651081,
					0.0690831020474, 0.0876999944448, 0.0532842241228,
					-0.045113991946, -0.0474013611674, 0.0553982891142,
					0.0792833119631, -0.025347430259, -0.0392380654812,
					0.0218577645719, 0.0443735644221, 0.0774717330933,
					0.103589653969, 0.0870641022921, 0.134377732873,
					0.179283767939, 0.119710952044, 0.0497783273458,
					0.01689443551, 0.0449694469571, 0.0646816194057,
					0.0050336192362, -0.121604382992, -0.202142447233,
					-0.117477491498, 0.0229430422187, 0.0177610628307,
					-0.0685159638524, -0.08196529001, -0.0204674545676,
					0.0263426434249, 0.0692918226123, 0.146855205297,
					0.154424875975, 0.0738313868642, -0.0310759879649,
					-0.0167284514755, 0.0902492627501, 0.109550833702,
					0.0810063779354, 0.0221588872373, -0.0171534903347,
					-0.0290717724711, -0.0698224529624, -0.0588994845748,
					-0.0344309695065, -0.0094269476831, 0.0132781285793,
					-0.0324905514717, -0.01220489759, 0.0698307082057,
					0.047199446708, -0.00692903250456, -0.00900745764375,
					-0.0316899158061, -0.0191606022418, 0.046706404537,
					0.0457795523107, 0.0249722003937, 0.0174277983606,
					-0.0257777050138, -0.00988260749727, 0.0420922264457,
					0.0537876076996, 0.0398545339704, -0.0180022194982,
					-0.0558604374528, -0.0850760117173, -0.0668053030968,
					-0.0503754913807, -0.000264999951469, 0.0770355537534,
					0.0621386542916, 0.0485193319619, 0.0772895589471,
					0.0628508776426, -0.018322750926, -0.0239282399416,
					0.0864839702845, 0.146090447903, 0.0462106540799,
					0.00160624750424, 0.0512568838894, 0.0443748421967,
					0.0737450569868, 0.113849416375, 0.0671659260988,
					-0.0141585161909, -0.0804363265634, -0.0423145107925,
					0.0483667440712, 0.0713385939598, 0.0419571436942,
					0.0234188213944, -0.0289908777922, -0.0349099636078,
					0.0610049068928, 0.0535475611687, -0.0486183911562,
					-0.0634869262576, -0.00629960047081, 0.0156593732536,
					0.0444448292255, 0.0651381760836, 0.0137887019664,
					-0.0150427035987, 0.0385581813753, 0.0873461812735,
					0.0636063441634, 0.0669691935182, 0.0935007631779,
					0.0733567848802, 0.0647877082229, 0.0554893910885,
					0.0115371551365, 0.00743253808469, 0.101859726012,
					0.118156090379, -0.0151035524905, -0.0926423445344,
					-0.0876015052199, -0.0894859805703, -0.061877027154,
					0.0108475228772, 0.117623664439, 0.141795799136,
					0.0830184668303, 0.0920427888632, 0.125270813704,
					0.0848467573524, 0.0439955890179, 0.0280093327165,
					0.0168264433742, 0.0353864319623, 0.0773392170668,
					0.0950430184603, 0.037123862654, 0.0130434315652,
					0.0229716598988, 0.00822925195098, -0.0174078755081,
					0.00717716570944, 0.0992233231664, 0.144968509674,
					0.0923328399658, -0.0305850636214, -0.0948080271482,
					-0.0373299270868, -0.00216765748337, -0.0386251546443,
					-0.0436581149697, 0.0337569080293, 0.0579238757491,
					-0.00935993343592, -0.0258462335914, -0.0263941474259,
					-0.00806314311922, 0.0538110509515, 0.0927913784981,
					0.0599665604532, 0.0468501672149, 0.0514370948076,
					-0.0883195102215, -0.14218750596, 0.0132273025811,
					0.05789488554, -0.0143932597712, -0.0249390527606,
					-0.0174218080938, 0.0208116881549, 0.0376449935138,
					0.000373328657588, 0.0547262281179, 0.0961854383349,
					0.0594072416425, 0.0533373467624, 0.04885167256,
					-0.00101263995748, -0.0059269266203, 0.0329577736557,
					-0.0106270667166, -0.048157889396, -0.0537960007787,
					-0.102348357439, -0.049735404551, 0.0880917534232,
					0.110402107239, 0.0179352872074, -0.00432011298835,
					0.0801115110517, 0.0978003144264, -0.0372120775282,
					-0.142332628369, -0.111255809665, -0.0280905552208,
					0.0498431548476, 0.0615027099848, 0.090424284339,
					0.122219264507, 0.0442051514983, -0.0107412971556,
					0.000499144545756, 0.0317788012326, 0.0548927932978,
					0.02819865942, 0.015764368698, 0.000433153589256,
					-0.0566953420639, -0.0284196101129, 0.027034804225,
					0.000533665064722, 0.023562412709, 0.0362496301532,
					0.0022197694052, -0.0420362874866, -0.123073115945,
					-0.0953237712383, 0.0159721560776, 0.0119237238541,
					-0.0296038873494, 0.00582700222731, 0.0264415238053,
					0.0174231249839, 0.0444517359138, 0.0877213329077,
					0.109926909208, 0.132537469268, 0.0991544499993,
					-0.0312183797359, -0.0371214486659, 0.0755192935467,
					0.0944863259792, 0.0288768596947, -0.0342580787838,
					-0.0199903286994, 0.0431848876178, 0.0618565268815,
					0.0628553554416, 0.101747646928, 0.0905963927507,
					0.0106366276741, 0.0164897628129, 0.0754096210003,
					0.0801295638084, 0.0848205313087, 0.118899106979,
					0.0932284072042, 0.0149769224226, -0.0142911672592,
					-0.0324169285595, -0.0609815791249, -0.0507140830159,
					-0.036364492029, 0.00176341028418, 0.088028870523,
					0.0981812775135, -0.0092253703624, -0.0593349412084,
					-0.0474360212684, -0.0556026212871, -0.0116434786469,
					-0.0193362087011, -0.0253674481064, 0.0691237896681,
					0.15214318037, 0.16926176846, 0.110575884581,
					0.0689285472035, 0.0915451794863, 0.0975448265672,
					0.0472521334887, -0.0605964623392, -0.0948007404804,
					-0.0579403117299, -0.0242439489812, 0.010055876337,
					0.026857342571, 0.0686936751008, 0.0499916747212,
					-0.0397594086826, -0.0475056618452, 0.0104643413797,
					0.0570648871362, 0.0175019279122, -0.0419451892376,
					0.018783070147, 0.0483043678105, -0.00333032291383,
					-0.0464136078954, -0.0345247983932, 0.0090623293072,
					0.0346554219723, 0.0109930997714, -0.00721018482,
					-8.79097351572e-05, -0.0399904549122, -0.0890389978886,
					-0.114344984293, -0.070639424026, 0.0479513779283,
					0.0886326953769, -0.00778271257877, -0.0839687287807,
					-0.035550005734, -0.0266483314335, -0.0965487062931,
					-0.0615692734718, 0.0294836945832, 0.0624305941164,
					0.0375565066934, 0.0526393949986, 0.130722910166,
					0.12011770159, 0.00777242705226, -0.0176053140312,
					0.0841448754072, 0.0588891617954, -0.0945539623499,
					-0.0722320973873, 0.0916741713881, 0.185856834054,
					0.14461542666, 0.091227337718, 0.100555002689,
					0.0579198002815, 0.0482142716646, 0.0678713321686,
					0.059321321547, 0.0704501643777, 0.0874607414007,
					0.0834267735481, 0.0486787594855, 0.0163939706981,
					0.00688076019287, 0.0188101809472, 0.0224951673299,
					0.0113448128104, 0.041007578373, 0.0484450682998,
					0.0096669504419, 0.0209840480238, 0.0526910834014,
					0.0470921732485, -0.0427842661738, -0.0751233547926,
					0.0210807174444, 0.0368148311973, -0.0306492820382,
					-0.0324413441122, 0.00200368813239, 0.00225207279436,
					0.00526733323932, -0.00143219763413, -0.0571224875748,
					-0.123857393861, -0.0532587841153, 0.0545741654932,
					0.078403070569, 0.0705190077424, -0.0177913494408,
					-0.0256861224771, 0.063413977623, 0.0115516446531,
					-0.0591211915016, 0.00527093745768, 0.0864070504904,
					0.121742248535, 0.0928697288036, -0.0153310950845,
					-0.0956026166677, -0.0428993478417, 0.00896662753075,
					0.0463737696409, 0.0994292721152, 0.141526848078,
					0.138729006052, 0.0467944703996, -0.0457921847701,
					-0.0458265505731, -0.0116812800989, -0.0118503700942,
					0.0327332615852, 0.0677635967731, 0.0377589911222,
					0.0308866761625, 0.000955870724283, -0.0436416938901,
					-0.0601240992546, -0.0686883330345, -0.0157162100077,
					0.0729954615235, 0.0478996895254, -0.0361267775297,
					-0.0434677861631, -0.0367834493518, -0.061325352639,
					-0.113285772502, -0.155366688967, -0.0890427976847,
					0.0739785432816

			};
			//float in_data[num_data];
			//SetFloatConstantWithGaussianNoise(0.0, 0.5, num_data, in_data);
			SIMD_ALIGN
			bool mask[ELEMENTSOF(in_data)];
			SetBoolConstant(true, ELEMENTSOF(in_data), mask);
			for (size_t i = 0; i < 120; ++i) {
				mask[i] = false;
			}
			for (size_t i = 3960; i < 4080; ++i) {
				mask[i] = false;
			}
			//cout << num_data << ((num_extra < num_extra_max) ? ", " : "");
			if (verbose) {
				PrintArray("in_data", num_data, in_data);
			}
			LIBSAKURA_SYMBOL(BaselineContext) * context = nullptr;
			LIBSAKURA_SYMBOL (Status) create_status =
					sakura_CreateBaselineContext(
							LIBSAKURA_SYMBOL(BaselineType_kCubicSpline), order,
							num_pieces, dummy_nwave, num_data, &context);
			EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
			SIMD_ALIGN
			double out[ELEMENTSOF(coeff)];
			float out2[ELEMENTSOF(in_data)];
			double answer[ELEMENTSOF(coeff)];
			for (size_t i = 0; i < ELEMENTSOF(coeff); ++i) {
				answer[i] = coeff[i];
			}
			float rms;
			SIMD_ALIGN
			double boundary[num_pieces];

			LIBSAKURA_SYMBOL(BaselineStatus) baseline_status;
			LIBSAKURA_SYMBOL (Status) sub_status =
			LIBSAKURA_SYMBOL(SubtractBaselineCubicSplineFloat)(context,
					num_pieces, num_data, in_data, mask, 5.0f, 1, true, mask,
					out2, &rms, boundary, &baseline_status);
			EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), sub_status);
			EXPECT_EQ(LIBSAKURA_SYMBOL(BaselineStatus_kOK), baseline_status);

			for (size_t i = 0; i < ELEMENTSOF(answer); ++i) {
				//CheckAlmostEqual(answer[i], out[i], 1.0e-6);
			}

			if (verbose) {
				//PrintArray("data  ", num_data, in_data);
				PrintArray("out   ", ELEMENTSOF(answer), out);
				std::cout << endl;
				//PrintArray("out2   ", ELEMENTSOF(out2), out2);
				//PrintArray("answer", ELEMENTSOF(answer), answer);
			}

			size_t count_big = 0;
			float out_min = 10000.0;
			float out_max = -10000.0;
			size_t idx_min = 0;
			size_t idx_max = 0;
			double out_mean = 0.0;
			double out_sqmean = 0.0;
			size_t num_gooddata = 0;
			for (size_t i = 120; i < 3960; ++i) {
				num_gooddata++;
				out_mean += (double) out2[i];
				out_sqmean += (double) out2[i] * (double) out2[i];
				if (out2[i] > out_max) {
					out_max = out2[i];
					idx_max = i;
				}
				if (out2[i] < out_min) {
					out_min = out2[i];
					idx_min = i;
				}
				if (fabs((double) out2[i]) > 0.3) {
					count_big++;
					//cout << "******  at i = " << i << ", out2 = " << out2[i] << endl;
				}
			}
			/*
			 cout << "number of deviated values (abs>0.3) : " << count_big
			 << endl;
			 out_mean /= (double) num_gooddata;
			 out_sqmean /= (double) num_gooddata;
			 double out_stddev = sqrt(out_sqmean - out_mean * out_mean);
			 cout << "rms = " << out_stddev << endl;
			 cout << "out2_min = " << out_min << "[at i = " << idx_min
			 << "],     ";
			 cout << "out2_max = " << out_max << "[at i = " << idx_max << "]"
			 << endl;
			 //cout << "out2[0] = " << out2[0] << ",     ";
			 //cout << "out2[4079] = " << out2[4079] << endl;
			 */
			LIBSAKURA_SYMBOL (Status) destroy_status =
					sakura_DestroyBaselineContext(context);
			EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);
		}
		//cout << endl;
	}
}

/*
 * Test GetBestFitBaselineCoefficientsCubicSpline
 * time-consuming successful case for performance measurement
 */
TEST_F(BaselineWK, GetBestFitBaselineCoefficientsCubicSplinePerformanceTest) {
	size_t const order = 0;
	size_t const num_repeat = 300;
	size_t const num_pieces = 2;
	SIMD_ALIGN
	double answer[4 * num_pieces];
	for (size_t i = 0; i < ELEMENTSOF(answer); i += 4) {
		answer[i] = 1.0;
		answer[i + 1] = 1e-4;
		answer[i + 2] = 1e-8;
		answer[i + 3] = 1e-12;
	}
	size_t const num_data = 70000;
	SIMD_ALIGN
	float in_data[num_data];
	SetFloatPolynomial(num_data, in_data, answer);
	SIMD_ALIGN
	bool mask[ELEMENTSOF(in_data)];
	SetBoolConstant(true, ELEMENTSOF(in_data), mask);
	if (verbose) {
		PrintArray("in_data", num_data, in_data);
	}
	LIBSAKURA_SYMBOL(BaselineContext) * context = nullptr;
	LIBSAKURA_SYMBOL (Status) create_status = sakura_CreateBaselineContext(
			LIBSAKURA_SYMBOL(BaselineType_kCubicSpline), order, num_pieces,
			dummy_nwave, num_data, &context);
	EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
	SIMD_ALIGN
	double out[ELEMENTSOF(answer)];
	float rms;
	SIMD_ALIGN
	double boundary[num_pieces];
	LIBSAKURA_SYMBOL(BaselineStatus) baseline_status;
	double start_time = sakura_GetCurrentTime();
	for (size_t i = 0; i < num_repeat; ++i) {
		LIBSAKURA_SYMBOL (Status) coeff_status = LIBSAKURA_SYMBOL(
				GetBestFitBaselineCoefficientsCubicSplineFloat)(context,
				num_data, in_data, mask, 5.0f, 1, num_pieces, out, mask,
				&rms, boundary, &baseline_status);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), coeff_status);
	}
	double end_time = sakura_GetCurrentTime();
	std::cout << std::setprecision(5)
			<< "#x# benchmark BaselineWK_GetBestFitBaselineCoefficientsCubicSplinePerformanceTest"
			<< " " << (end_time - start_time) << std::endl;

	EXPECT_EQ(LIBSAKURA_SYMBOL(BaselineStatus_kOK), baseline_status);

	if (verbose) {
		PrintArray("data  ", num_data, in_data);
		PrintArray("out   ", ELEMENTSOF(answer), out);
		PrintArray("answer", ELEMENTSOF(answer), answer);
	}

	LIBSAKURA_SYMBOL (Status) destroy_status = sakura_DestroyBaselineContext(
			context);
	EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);
}

/*
 * Test GetBestFitBaselineCoefficientsCubicSpline
 * erroneous cases: null pointer cases
 * parameters to be tested include context, data, mask, coeff, final_mask and baseline_status.
 */
TEST_F(BaselineWK, GetBestFitBaselineCoefficientsCubicSplineErroneousCasesNullPointer) {
	size_t const order = 0;
	enum NPItems {
		NP_kContext,
		NP_kData,
		NP_kMask,
		NP_kCoeff,
		NP_kFinalMask,
		NP_kBoundary,
		NP_kBaselineStatus,
		NP_kNumElems
	};
	vector<string> np_param_names = { "context", "data", "mask", "coeff",
			"final_mask", "boundary", "baseline_status" };
	cout << "    Testing for ";

	for (NPItems item = static_cast<NPItems>(0); item < NP_kNumElems; item =
			static_cast<NPItems>(item + 1)) {
		cout << np_param_names[item] << ((item < NP_kNumElems - 1) ? ", " : "");
		size_t const num_pieces = 2;
		size_t const num_data = 10;
		double coeff[4];
		SetDoubleConstant(1.0, ELEMENTSOF(coeff), coeff);
		SIMD_ALIGN
		float in_data[num_data];
		SetFloatPolynomial(num_data, in_data, coeff);
		SIMD_ALIGN
		bool mask[ELEMENTSOF(in_data)];
		SetBoolConstant(true, ELEMENTSOF(in_data), mask);
		SIMD_ALIGN
		bool final_mask[ELEMENTSOF(in_data)];
		SIMD_ALIGN
		double out[ELEMENTSOF(coeff)];
		LIBSAKURA_SYMBOL(BaselineContext) *context = nullptr;
		LIBSAKURA_SYMBOL (Status) create_status = sakura_CreateBaselineContext(
				LIBSAKURA_SYMBOL(BaselineType_kCubicSpline), order, num_pieces,
				dummy_nwave, num_data, &context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
		float rms;
		SIMD_ALIGN
		double boundary[num_pieces];
		LIBSAKURA_SYMBOL(BaselineStatus) baseline_status;

		float *in_data_ptr = in_data;
		bool *mask_ptr = mask;
		bool *final_mask_ptr = final_mask;
		double *out_ptr = out;
		double *boundary_ptr = boundary;
		LIBSAKURA_SYMBOL(BaselineContext) *context_ptr = context;
		LIBSAKURA_SYMBOL(BaselineStatus) *baseline_status_ptr = &baseline_status;

		switch (item) {
		case NP_kData:
			in_data_ptr = nullptr;
			break;
		case NP_kMask:
			mask_ptr = nullptr;
			break;
		case NP_kCoeff:
			out_ptr = nullptr;
			break;
		case NP_kFinalMask:
			final_mask_ptr = nullptr;
			break;
		case NP_kContext:
			context_ptr = nullptr;
			break;
		case NP_kBoundary:
			boundary_ptr = nullptr;
			break;
		case NP_kBaselineStatus:
			baseline_status_ptr = nullptr;
			break;
		default:
			assert(false);
		}

		LIBSAKURA_SYMBOL (Status) coeff_status = LIBSAKURA_SYMBOL(
				GetBestFitBaselineCoefficientsCubicSplineFloat)(context_ptr,
				num_data, in_data_ptr, mask_ptr, 5.0f, 1, num_pieces, out_ptr,
				final_mask_ptr, &rms, boundary_ptr, baseline_status_ptr);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kInvalidArgument), coeff_status);

		LIBSAKURA_SYMBOL (Status) destroy_status =
				sakura_DestroyBaselineContext(context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);
	}
	cout << endl;
}

/*
 * Test GetBestFitBaselineCoefficientsCubicSpline
 * erroneous cases: unaligned cases
 * parameters to be tested include data, mask, coeff and final_mask.
 */
TEST_F(BaselineWK, GetBestFitBaselineCoefficientsCubicSplineErroneousCasesUnaligned) {
	size_t const order = 0;
	enum UAItems {
		UA_kData, UA_kMask, UA_kCoeff, UA_kFinalMask, UA_kBoundary, UA_kNumElems
	};
	vector<string> ua_param_names = { "data", "mask", "coeff", "final_mask", "boundary" };
	cout << "    Testing for ";

	for (UAItems item = static_cast<UAItems>(0); item < UA_kNumElems; item =
			static_cast<UAItems>(item + 1)) {
		cout << ua_param_names[item] << ((item < UA_kNumElems - 1) ? ", " : "");
		size_t const num_pieces = 2;
		size_t const num_data = 10;
		double coeff[4];
		SetDoubleConstant(1.0, ELEMENTSOF(coeff), coeff);
		SIMD_ALIGN
		float in_data[num_data + 1];
		SetFloatPolynomial(num_data, in_data, coeff);
		SIMD_ALIGN
		bool mask[ELEMENTSOF(in_data)];
		SetBoolConstant(true, ELEMENTSOF(in_data), mask);
		SIMD_ALIGN
		bool final_mask[ELEMENTSOF(in_data)];
		SIMD_ALIGN
		double out[ELEMENTSOF(coeff) + 1];
		float rms;
		SIMD_ALIGN
		double boundary[num_pieces + 1];
		LIBSAKURA_SYMBOL(BaselineContext) *context = nullptr;
		LIBSAKURA_SYMBOL (Status) create_status = sakura_CreateBaselineContext(
				LIBSAKURA_SYMBOL(BaselineType_kCubicSpline), order, num_pieces,
				dummy_nwave, num_data, &context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
		LIBSAKURA_SYMBOL(BaselineStatus) baseline_status;

		float *in_data_ptr = in_data;
		bool *mask_ptr = mask;
		bool *final_mask_ptr = final_mask;
		double *out_ptr = out;
		double *boundary_ptr = boundary;

		switch (item) {
		case UA_kData:
			++in_data_ptr;
			assert(!LIBSAKURA_SYMBOL(IsAligned)(in_data_ptr));
			break;
		case UA_kMask:
			++mask_ptr;
			assert(!LIBSAKURA_SYMBOL(IsAligned)(mask_ptr));
			break;
		case UA_kCoeff:
			++out_ptr;
			assert(!LIBSAKURA_SYMBOL(IsAligned)(out_ptr));
			break;
		case UA_kFinalMask:
			++final_mask_ptr;
			assert(!LIBSAKURA_SYMBOL(IsAligned)(final_mask_ptr));
			break;
		case UA_kBoundary:
			++boundary_ptr;
			assert(!LIBSAKURA_SYMBOL(IsAligned)(boundary_ptr));
			break;
		default:
			assert(false);
		}

		LIBSAKURA_SYMBOL (Status) coeff_status =
		LIBSAKURA_SYMBOL(GetBestFitBaselineCoefficientsCubicSplineFloat)(
				context, num_data, in_data_ptr, mask_ptr, 5.0f, 1, num_pieces,
				out_ptr, final_mask_ptr, &rms, boundary_ptr, &baseline_status);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kInvalidArgument), coeff_status);

		LIBSAKURA_SYMBOL (Status) destroy_status =
				sakura_DestroyBaselineContext(context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);
	}
	cout << endl;
}

/*
 * Test GetBestFitBaselineCoefficientsCubicSpline
 * erroneous cases: bad parameter value cases as follows:
 *     (1) num_data < context->num_bases
 *     (2) num_data < (!=) context->num_basis_data
 *     (3) num_data > (!=) context->num_basis_data
 */
TEST_F(BaselineWK, GetBestFitBaselineCoefficientsCubicSplineErroneousCasesBadParameterValue) {
	size_t const order = 0;
	enum BVItems {
		BV_kDataLTNumBases,
		BV_kDataLTNumBasisData,
		BV_kDataGTNumBasisData,
		BV_kNumElems
	};
	vector<string> bv_param_names = { "(num_data < context->num_bases)",
			"(num_data < context->num_basis_data)",
			"(num_data > context->num_basis_data)" };
	cout << "    Testing for cases " << endl;

	for (BVItems item = static_cast<BVItems>(0); item < BV_kNumElems; item =
			static_cast<BVItems>(item + 1)) {
		cout << "        " << bv_param_names[item]
				<< ((item < BV_kNumElems - 1) ? ", " : "") << endl;
		size_t const num_pieces = 1;
		size_t num_data = 0;
		switch (item) {
		case BV_kDataLTNumBases:
			num_data = 2;
			break;
		case BV_kDataLTNumBasisData:
			num_data = 5;
			break;
		case BV_kDataGTNumBasisData:
			num_data = 15;
			break;
		default:
			assert(false);
		}
		size_t num_basis_data = 10;

		double coeff[4];
		SetDoubleConstant(1.0, ELEMENTSOF(coeff), coeff);
		SIMD_ALIGN
		float in_data[num_data];
		SetFloatPolynomial(num_data, in_data, coeff);
		SIMD_ALIGN
		bool mask[ELEMENTSOF(in_data)];
		SetBoolConstant(true, ELEMENTSOF(in_data), mask);
		SIMD_ALIGN
		bool final_mask[ELEMENTSOF(in_data)];
		SIMD_ALIGN
		double out[ELEMENTSOF(coeff)];
		float rms;
		SIMD_ALIGN
		double boundary[num_pieces];
		LIBSAKURA_SYMBOL(BaselineContext) *context = nullptr;
		LIBSAKURA_SYMBOL (Status) create_status = sakura_CreateBaselineContext(
				LIBSAKURA_SYMBOL(BaselineType_kCubicSpline), order, num_pieces,
				dummy_nwave, num_basis_data, &context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
		LIBSAKURA_SYMBOL(BaselineStatus) baseline_status;

		LIBSAKURA_SYMBOL (Status) coeff_status = LIBSAKURA_SYMBOL(
				GetBestFitBaselineCoefficientsCubicSplineFloat)(context,
				num_data, in_data, mask, 5.0f, 1, num_pieces, out, final_mask,
				&rms, boundary, &baseline_status);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kInvalidArgument), coeff_status);

		LIBSAKURA_SYMBOL (Status) destroy_status =
				sakura_DestroyBaselineContext(context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);
	}
}

/*
 * Test sakura_SubtractBaselineCubicSplineFloat
 * successful case
 * subtract best fit model from input data
 */
TEST_F(BaselineWK, SubtractBaselineCubicSplineSuccessfulCase) {
	size_t const order = 0;
	for (size_t num_pieces = 1; num_pieces <= 3; ++num_pieces) {
		cout << "    Testing for num_pieces = " << num_pieces
				<< " cases: num_data = ";
		size_t num_extra_max = 3;
		for (size_t num_extra = 0; num_extra <= num_extra_max; ++num_extra) {
			size_t const num_data = 4 * num_pieces + num_extra;
			cout << num_data << ((num_extra < num_extra_max) ? ", " : "");
			double coeff[4];
			SetDoubleConstant(1.0, ELEMENTSOF(coeff), coeff);
			SIMD_ALIGN
			float in_data[num_data];
			SetFloatPolynomial(num_data, in_data, coeff);
			SIMD_ALIGN
			bool mask[ELEMENTSOF(in_data)];
			SetBoolConstant(true, ELEMENTSOF(in_data), mask);
			if (verbose) {
				PrintArray("in_data", num_data, in_data);
			}
			LIBSAKURA_SYMBOL(BaselineContext) * context = nullptr;
			LIBSAKURA_SYMBOL (Status) create_status =
					sakura_CreateBaselineContext(
							LIBSAKURA_SYMBOL(BaselineType_kCubicSpline), order,
							num_pieces, dummy_nwave, num_data, &context);
			EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
			SIMD_ALIGN
			float out[ELEMENTSOF(in_data)];
			SIMD_ALIGN
			float answer[ELEMENTSOF(in_data)];
			SetFloatConstant(0.0, ELEMENTSOF(in_data), answer);
			float rms;
			SIMD_ALIGN
			double boundary[num_pieces];

			LIBSAKURA_SYMBOL(BaselineStatus) baseline_status;
			LIBSAKURA_SYMBOL(Status) sub_status =
			LIBSAKURA_SYMBOL(SubtractBaselineCubicSplineFloat)(context,
					num_pieces, num_data, in_data, mask, 5.0f, 1, true, mask,
					out, &rms, boundary, &baseline_status);
			EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), sub_status);
			EXPECT_EQ(LIBSAKURA_SYMBOL(BaselineStatus_kOK), baseline_status);

			for (size_t i = 0; i < ELEMENTSOF(answer); ++i) {
				CheckAlmostEqual(answer[i], out[i], 1.0e-6);
			}

			if (verbose) {
				PrintArray("data  ", num_data, in_data);
				PrintArray("out   ", ELEMENTSOF(answer), out);
				PrintArray("answer", ELEMENTSOF(answer), answer);
			}

			LIBSAKURA_SYMBOL (Status) destroy_status =
					sakura_DestroyBaselineContext(context);
			EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);
		}
		cout << endl;
	}
}

/*
 * Test SubtractBaselineCubicSplineFloat
 * time-consuming successful case for performance measurement
 */
TEST_F(BaselineWK, SubtractBaselineCubicSplinePerformanceTest) {
	size_t const order = 0;
	size_t const num_repeat = 300;
	size_t const num_pieces = 2;
	size_t const num_data = 70000;
	SIMD_ALIGN
	float in_data[num_data];
	double coeff[4] = { 1.0, 1e-4, 1e-8, 1e-12 };
	SetFloatPolynomial(num_data, in_data, coeff);
	SIMD_ALIGN
	bool mask[ELEMENTSOF(in_data)];
	SetBoolConstant(true, ELEMENTSOF(in_data), mask);
	if (verbose) {
		PrintArray("in_data", num_data, in_data);
	}
	LIBSAKURA_SYMBOL(BaselineContext) * context = nullptr;
	LIBSAKURA_SYMBOL (Status) create_status = sakura_CreateBaselineContext(
			LIBSAKURA_SYMBOL(BaselineType_kCubicSpline), order, num_pieces,
			dummy_nwave, num_data, &context);
	EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
	SIMD_ALIGN
	float out[ELEMENTSOF(in_data)];
	LIBSAKURA_SYMBOL(BaselineStatus) baseline_status;
	SIMD_ALIGN
	double answer[ELEMENTSOF(in_data)];
	SetDoubleConstant(0.0, ELEMENTSOF(in_data), answer);
	float rms;
	SIMD_ALIGN
	double boundary[num_pieces];
	double start_time = sakura_GetCurrentTime();
	for (size_t i = 0; i < num_repeat; ++i) {
		LIBSAKURA_SYMBOL(Status) sub_status =
		LIBSAKURA_SYMBOL(SubtractBaselineCubicSplineFloat)(context, num_pieces,
				num_data, in_data, mask, 5.0f, 1, true, mask, out,
				&rms, boundary, &baseline_status);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), sub_status);
	}
	double end_time = sakura_GetCurrentTime();
	std::cout << std::setprecision(5)
			<< "#x# benchmark BaselineWK_SubtractBaselineCubicSplinePerformanceTest"
			<< " " << (end_time - start_time) << std::endl;
	EXPECT_EQ(LIBSAKURA_SYMBOL(BaselineStatus_kOK), baseline_status);

	if (verbose) {
		PrintArray("data  ", num_data, in_data);
		PrintArray("out   ", ELEMENTSOF(answer), out);
		PrintArray("answer", ELEMENTSOF(answer), answer);
	}

	LIBSAKURA_SYMBOL (Status) destroy_status = sakura_DestroyBaselineContext(
			context);
	EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);
}

/*
 * Test SubtractBaselineCubicSplineFloat
 * erroneous cases: null pointer cases
 * parameters to be tested include context, data, mask, final_mask, out and baseline_status.
 */
TEST_F(BaselineWK, SubtractBaselineCubicSplineErroneousCasesNullPointer) {
	size_t const order = 0;
	enum NPItems {
		NP_kContext,
		NP_kData,
		NP_kMask,
		NP_kFinalMask,
		NP_kOut,
		NP_kBoundary,
		NP_kBaselineStatus,
		NP_kNumElems
	};
	vector<string> np_param_names = { "context", "data", "mask", "final_mask",
			"out", "boundary", "baseline_status" };
	cout << "    Testing for ";

	for (NPItems item = static_cast<NPItems>(0); item < NP_kNumElems; item =
			static_cast<NPItems>(item + 1)) {
		cout << np_param_names[item] << ((item < NP_kNumElems - 1) ? ", " : "");
		size_t const num_pieces = 2;
		size_t const num_data = 10;
		double coeff[4];
		SetDoubleConstant(1.0, ELEMENTSOF(coeff), coeff);
		SIMD_ALIGN
		float in_data[num_data];
		SetFloatPolynomial(num_data, in_data, coeff);
		SIMD_ALIGN
		bool mask[ELEMENTSOF(in_data)];
		SetBoolConstant(true, ELEMENTSOF(in_data), mask);
		SIMD_ALIGN
		bool final_mask[ELEMENTSOF(in_data)];
		SIMD_ALIGN
		float out[ELEMENTSOF(in_data)];
		LIBSAKURA_SYMBOL(BaselineContext) *context = nullptr;
		LIBSAKURA_SYMBOL (Status) create_status = sakura_CreateBaselineContext(
				LIBSAKURA_SYMBOL(BaselineType_kCubicSpline), order, num_pieces,
				dummy_nwave, num_data, &context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
		LIBSAKURA_SYMBOL(BaselineStatus) baseline_status;
		float rms;
		SIMD_ALIGN
		double boundary[num_pieces];

		float *in_data_ptr = in_data;
		bool *mask_ptr = mask;
		bool *final_mask_ptr = final_mask;
		float *out_ptr = out;
		double *boundary_ptr = boundary;
		LIBSAKURA_SYMBOL(BaselineContext) *context_ptr = context;
		LIBSAKURA_SYMBOL(BaselineStatus) *baseline_status_ptr = &baseline_status;

		switch (item) {
		case NP_kData:
			in_data_ptr = nullptr;
			break;
		case NP_kMask:
			mask_ptr = nullptr;
			break;
		case NP_kFinalMask:
			final_mask_ptr = nullptr;
			break;
		case NP_kOut:
			out_ptr = nullptr;
			break;
		case NP_kContext:
			context_ptr = nullptr;
			break;
		case NP_kBoundary:
			boundary_ptr = nullptr;
			break;
		case NP_kBaselineStatus:
			baseline_status_ptr = nullptr;
			break;
		default:
			assert(false);
		}

		LIBSAKURA_SYMBOL(Status) sub_status =
		LIBSAKURA_SYMBOL(SubtractBaselineCubicSplineFloat)(context_ptr,
				num_pieces, num_data, in_data_ptr, mask_ptr, 5.0f, 1, true,
				final_mask_ptr, out_ptr, &rms, boundary_ptr, baseline_status_ptr);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kInvalidArgument), sub_status);

		LIBSAKURA_SYMBOL (Status) destroy_status =
				sakura_DestroyBaselineContext(context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);
	}
	cout << endl;
}

/*
 * Test SubtractBaselineCubicSplineFloat
 * erroneous cases: unaligned cases
 * parameters to be tested include data, mask, final_mask and out
 */
TEST_F(BaselineWK, SubtractBaselineCubicSplineErroneousCasesUnaligned) {
	size_t const order = 0;
	enum UAItems {
		UA_kData, UA_kMask, UA_kFinalMask, UA_kOut, UA_kBoundary, UA_kNumElems
	};
	vector<string> ua_param_names = { "data", "mask", "final_mask", "out", "boundary" };
	cout << "    Testing for ";

	for (UAItems item = static_cast<UAItems>(0); item < UA_kNumElems; item =
			static_cast<UAItems>(item + 1)) {
		cout << ua_param_names[item] << ((item < UA_kNumElems - 1) ? ", " : "");
		size_t const num_pieces = 2;
		size_t const num_data = 10;
		double coeff[4];
		SetDoubleConstant(1.0, ELEMENTSOF(coeff), coeff);
		SIMD_ALIGN
		float in_data[num_data + 1];
		SetFloatPolynomial(num_data, in_data, coeff);
		SIMD_ALIGN
		bool mask[ELEMENTSOF(in_data)];
		SetBoolConstant(true, ELEMENTSOF(in_data), mask);
		SIMD_ALIGN
		bool final_mask[ELEMENTSOF(in_data)];
		SIMD_ALIGN
		float out[ELEMENTSOF(in_data)];
		LIBSAKURA_SYMBOL(BaselineContext) *context = nullptr;
		LIBSAKURA_SYMBOL (Status) create_status = sakura_CreateBaselineContext(
				LIBSAKURA_SYMBOL(BaselineType_kCubicSpline), order, num_pieces,
				dummy_nwave, num_data, &context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
		float rms;
		SIMD_ALIGN
		double boundary[num_pieces + 1];
		LIBSAKURA_SYMBOL(BaselineStatus) baseline_status;

		float *in_data_ptr = in_data;
		bool *mask_ptr = mask;
		bool *final_mask_ptr = final_mask;
		float *out_ptr = out;
		double *boundary_ptr = boundary;

		switch (item) {
		case UA_kData:
			++in_data_ptr;
			assert(!LIBSAKURA_SYMBOL(IsAligned)(in_data_ptr));
			break;
		case UA_kMask:
			++mask_ptr;
			assert(!LIBSAKURA_SYMBOL(IsAligned)(mask_ptr));
			break;
		case UA_kFinalMask:
			++final_mask_ptr;
			assert(!LIBSAKURA_SYMBOL(IsAligned)(final_mask_ptr));
			break;
		case UA_kOut:
			++out_ptr;
			assert(!LIBSAKURA_SYMBOL(IsAligned)(out_ptr));
			break;
		case UA_kBoundary:
			++boundary_ptr;
			assert(!LIBSAKURA_SYMBOL(IsAligned)(boundary_ptr));
			break;
		default:
			assert(false);
		}

		LIBSAKURA_SYMBOL(Status) sub_status =
		LIBSAKURA_SYMBOL(SubtractBaselineCubicSplineFloat)(context, num_pieces,
				num_data, in_data_ptr, mask_ptr, 5.0f, 1, true, final_mask_ptr,
				out_ptr, &rms, boundary_ptr, &baseline_status);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kInvalidArgument), sub_status);

		LIBSAKURA_SYMBOL (Status) destroy_status =
				sakura_DestroyBaselineContext(context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);
	}
	cout << endl;
}

/*
 * Test SubtractBaselineCubicSplineFloat
 * erroneous cases: bad parameter value cases as follows:
 *     (1) num_data < context->num_bases
 *     (2) num_data < (!=) context->num_basis_data
 *     (3) num_data > (!=) context->num_basis_data
 */
TEST_F(BaselineWK, SubtractBaselineCubicSplineErroneousCasesBadParameterValue) {
	size_t const order = 0;
	enum BVItems {
		BV_kDataLTNumBases,
		BV_kDataLTNumBasisData,
		BV_kDataGTNumBasisData,
		BV_kNumElems
	};
	vector<string> bv_param_names = { "(num_data < context->num_bases)",
			"(num_data < context->num_basis_data)",
			"(num_data > context->num_basis_data)" };
	cout << "    Testing for cases " << endl;

	for (BVItems item = static_cast<BVItems>(0); item < BV_kNumElems; item =
			static_cast<BVItems>(item + 1)) {
		cout << "        " << bv_param_names[item]
				<< ((item < BV_kNumElems - 1) ? ", " : "") << endl;
		size_t const num_pieces = 1;
		size_t num_data = 0;
		switch (item) {
		case BV_kDataLTNumBases:
			num_data = 2;
			break;
		case BV_kDataLTNumBasisData:
			num_data = 5;
			break;
		case BV_kDataGTNumBasisData:
			num_data = 15;
			break;
		default:
			assert(false);
		}
		size_t num_basis_data = 10;

		double coeff[4];
		SetDoubleConstant(1.0, ELEMENTSOF(coeff), coeff);
		SIMD_ALIGN
		float in_data[num_data];
		SetFloatPolynomial(num_data, in_data, coeff);
		SIMD_ALIGN
		bool mask[ELEMENTSOF(in_data)];
		SetBoolConstant(true, ELEMENTSOF(in_data), mask);
		SIMD_ALIGN
		bool final_mask[ELEMENTSOF(in_data)];
		SIMD_ALIGN
		float out[ELEMENTSOF(in_data)];
		float rms;
		SIMD_ALIGN
		double boundary[num_pieces];
		LIBSAKURA_SYMBOL(BaselineContext) *context = nullptr;
		LIBSAKURA_SYMBOL (Status) create_status = sakura_CreateBaselineContext(
				LIBSAKURA_SYMBOL(BaselineType_kCubicSpline), order, num_pieces,
				dummy_nwave, num_basis_data, &context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
		LIBSAKURA_SYMBOL(BaselineStatus) baseline_status;

		LIBSAKURA_SYMBOL(Status) sub_status =
		LIBSAKURA_SYMBOL(SubtractBaselineCubicSplineFloat)(context, num_pieces,
				num_data, in_data, mask, 5.0f, 1, true, final_mask, out,
				&rms, boundary, &baseline_status);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kInvalidArgument), sub_status);

		LIBSAKURA_SYMBOL (Status) destroy_status =
				sakura_DestroyBaselineContext(context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);
	}
}

/*
 * Test GetBestFitBaselineCoefficientsSinusoid
 * successful cases
 * compute the best-fit baseline coefficients for sinusoid
 * context is created with maximum nwave of 2 in all cases, that is,
 * context contains bases with nwave of 0(constant), 1(sin/cos)
 * and 2(sin/cos).
 * test cases: all combinations of nwave between 0 and 2.
 */
TEST_F(BaselineWK, GetBestFitBaselineCoefficientsSinusoidSuccessfulCase) {
	size_t const dummy = 1;
	size_t const context_nwave = 3;
	size_t const num_nwave_set = 4;
	size_t const nwave_set_length[num_nwave_set] = { 4, 6, 4, 1 };
	size_t nwave_set1[4][1] = { { 0 }, { 1 }, { 2 }, { 3 } };
	size_t nwave_set2[6][2] = { { 0, 1 }, { 0, 2 }, { 0, 3 }, { 1, 2 },
			{ 1, 3 }, { 2, 3 } };
	size_t nwave_set3[4][3] = { { 0, 1, 2 }, { 0, 1, 3 }, { 0, 2, 3 },
			{ 1, 2, 3 } };
	size_t nwave_set4[1][4] = { { 0, 1, 2, 3 } };
	cout << "    Baseline context has sinusoidal bases with nwave up to 3..."
			<< endl;

	for (size_t num_nwave = 1; num_nwave <= num_nwave_set; ++num_nwave) {
		cout << "    Testing for num_nwave = " << num_nwave << ": nwave = ";

		size_t const num_cases = nwave_set_length[num_nwave - 1];
		size_t nwave[num_nwave];
		for (size_t j = 0; j < num_cases; ++j) {
			cout << "{";
			for (size_t k = 0; k < num_nwave; ++k) {
				if (num_nwave == 1) {
					nwave[k] = nwave_set1[j][k];
				} else if (num_nwave == 2) {
					nwave[k] = nwave_set2[j][k];
				} else if (num_nwave == 3) {
					nwave[k] = nwave_set3[j][k];
				} else if (num_nwave == 4) {
					nwave[k] = nwave_set4[j][k];
				}
				cout << nwave[k];
				if (k < num_nwave - 1) {
					cout << ", ";
				}
			}
			cout << "}";
			if (j < num_cases - 1) {
				cout << ", ";
			}
			size_t num_coeff =
					(nwave[0] == 0) ? (2 * num_nwave - 1) : (2 * num_nwave);
			double coeff[num_coeff];
			SetDoubleConstant(1.0, num_coeff, coeff);
			size_t const num_data = NUM_DATA2;
			SIMD_ALIGN
			float in_data[num_data];
			SetFloatSinusoidal(num_nwave, nwave, coeff, num_data, in_data);
			SIMD_ALIGN
			bool mask[ELEMENTSOF(in_data)];
			SetBoolConstant(true, ELEMENTSOF(in_data), mask);
			LIBSAKURA_SYMBOL(BaselineContext) * context = nullptr;
			LIBSAKURA_SYMBOL (Status) create_status =
					sakura_CreateBaselineContext(
							LIBSAKURA_SYMBOL(BaselineType_kSinusoid), dummy,
							dummy, context_nwave, num_data, &context);
			EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
			SIMD_ALIGN
			double out[ELEMENTSOF(coeff)];
			double answer[ELEMENTSOF(coeff)];
			for (size_t i = 0; i < ELEMENTSOF(coeff); ++i) {
				answer[i] = coeff[i];
			}
			float rms;
			LIBSAKURA_SYMBOL(BaselineStatus) baseline_status;
			LIBSAKURA_SYMBOL (Status) coeff_status = LIBSAKURA_SYMBOL(
					GetBestFitBaselineCoefficientsSinusoidFloat)(context,
					num_data, in_data, mask, 5.0f, 1, num_nwave, nwave,
					num_coeff, out, mask, &rms, &baseline_status);
			EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), coeff_status);
			EXPECT_EQ(LIBSAKURA_SYMBOL(BaselineStatus_kOK), baseline_status);

			for (size_t i = 0; i < ELEMENTSOF(answer); ++i) {
				CheckAlmostEqual(answer[i], out[i], 1.0e-6);
			}
			if (verbose) {
				PrintArray("data  ", num_data, in_data);
				PrintArray("out   ", ELEMENTSOF(answer), out);
				PrintArray("answer", ELEMENTSOF(answer), answer);
			}

			LIBSAKURA_SYMBOL (Status) destroy_status =
					sakura_DestroyBaselineContext(context);
			EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);

		}
		cout << endl;
	}
}

/*
 * Test GetBestFitBaselineCoefficientsSinusoid
 * successful cases with masked data
 */
TEST_F(BaselineWK, GetBestFitBaselineCoefficientsSinusoidSuccessfulCaseWithMaskedData) {
	size_t const num_data = NUM_DATA2;
	size_t const dummy = 1;
	size_t const context_nwave = 2;
	size_t const num_nwave = 3;
	size_t nwave[num_nwave] = { 0, 1, 2 };
	size_t num_coeff = (nwave[0] == 0) ? (2 * num_nwave - 1) : (2 * num_nwave);
	double coeff[num_coeff];
	SetDoubleConstant(1.0, num_coeff, coeff);
	SIMD_ALIGN
	float in_data[num_data];
	SetFloatSinusoidal(num_nwave, nwave, coeff, num_data, in_data);
	SIMD_ALIGN
	bool mask[ELEMENTSOF(in_data)];
	SetBoolConstant(true, ELEMENTSOF(in_data), mask);
	LIBSAKURA_SYMBOL(BaselineContext) * context = nullptr;
	LIBSAKURA_SYMBOL (Status) create_status = sakura_CreateBaselineContext(
			LIBSAKURA_SYMBOL(BaselineType_kSinusoid), dummy, dummy,
			context_nwave, num_data, &context);
	EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
	SIMD_ALIGN
	double out[ELEMENTSOF(coeff)];
	double answer[ELEMENTSOF(coeff)];
	for (size_t i = 0; i < ELEMENTSOF(coeff); ++i) {
		answer[i] = coeff[i];
	}
	float rms;
	LIBSAKURA_SYMBOL(BaselineStatus) baseline_status;
	LIBSAKURA_SYMBOL (Status) coeff_status;
	for (size_t i = 0; i < 4; ++i) {
		size_t num_masked_idx = 1;
		if (i == 3) num_masked_idx = 2;
		size_t masked_idx[num_masked_idx];
		if (i == 0) { // masked at about the middle
			masked_idx[0] = ELEMENTSOF(in_data)/2;
		} else if (i == 1) { // masked at left edge
			masked_idx[0] = 0;
		} else if (i == 2) { // masked at right edge
			masked_idx[0] = ELEMENTSOF(in_data)-1;
		} else if (i == 3) { // masked at both edges
			masked_idx[0] = 0;
			masked_idx[1] = ELEMENTSOF(in_data)-1;
		}
		for (size_t j = 0; j < num_masked_idx; ++j) {
			mask[masked_idx[j]] = false;
			in_data[masked_idx[j]] = 10.0; // spike, which should not affect the fitting result
		}
		coeff_status = LIBSAKURA_SYMBOL(
				GetBestFitBaselineCoefficientsSinusoidFloat)(context, num_data,
				in_data, mask, 5.0f, 1, num_nwave, nwave, num_coeff, out, mask,
				&rms, &baseline_status);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), coeff_status);
		EXPECT_EQ(LIBSAKURA_SYMBOL(BaselineStatus_kOK), baseline_status);
		for (size_t j = 0; j < ELEMENTSOF(answer); ++j) {
		        CheckAlmostEqual(answer[j], out[j], 1.0e-6);
		}
	}

	if (verbose) {
		PrintArray("data  ", num_data, in_data);
		PrintArray("out   ", ELEMENTSOF(answer), out);
		PrintArray("answer", ELEMENTSOF(answer), answer);
	}

	LIBSAKURA_SYMBOL (Status) destroy_status = sakura_DestroyBaselineContext(
			context);
	EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);

}

/*
 * Test GetBestFitBaselineCoefficientsSinusoid
 * time-consuming successful case for performance measurement
 */
TEST_F(BaselineWK, GetBestFitBaselineCoefficientsSinusoidPerformanceTest) {
	size_t const num_repeat = 100;
	size_t const num_data = 50000;
	size_t const dummy = 1;
	size_t const context_nwave = 10;
	size_t const num_nwave = 10;
	size_t nwave[num_nwave] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
	size_t num_coeff = (nwave[0] == 0) ? (2 * num_nwave - 1) : (2 * num_nwave);
	double coeff[num_coeff];
	SetDoubleConstant(1.0, num_coeff, coeff);
	SIMD_ALIGN
	float in_data[num_data];
	SetFloatSinusoidal(num_nwave, nwave, coeff, num_data, in_data);
	SIMD_ALIGN
	bool mask[ELEMENTSOF(in_data)];
	SetBoolConstant(true, ELEMENTSOF(in_data), mask);
	LIBSAKURA_SYMBOL(BaselineContext) * context = nullptr;
	LIBSAKURA_SYMBOL (Status) create_status = sakura_CreateBaselineContext(
			LIBSAKURA_SYMBOL(BaselineType_kSinusoid), dummy, dummy,
			context_nwave, num_data, &context);
	EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
	SIMD_ALIGN
	double out[ELEMENTSOF(coeff)];
	double answer[ELEMENTSOF(coeff)];
	for (size_t i = 0; i < ELEMENTSOF(coeff); ++i) {
		answer[i] = coeff[i];
	}
	float rms;
	LIBSAKURA_SYMBOL(BaselineStatus) baseline_status;
	LIBSAKURA_SYMBOL (Status) coeff_status;
	double start_time = sakura_GetCurrentTime();
	for (size_t i = 0; i < num_repeat; ++i) {
		coeff_status = LIBSAKURA_SYMBOL(
				GetBestFitBaselineCoefficientsSinusoidFloat)(context, num_data,
				in_data, mask, 5.0f, 1, num_nwave, nwave, num_coeff, out, mask,
				&rms, &baseline_status);
	}
	double end_time = sakura_GetCurrentTime();
	std::cout << std::setprecision(5)
			<< "#x# benchmark BaselineWK_GetBestFitBaselineCoefficientsSinusoidPerformanceTest"
			<< " " << (end_time - start_time) << std::endl;
	EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), coeff_status);
	EXPECT_EQ(LIBSAKURA_SYMBOL(BaselineStatus_kOK), baseline_status);

	for (size_t i = 0; i < ELEMENTSOF(answer); ++i) {
		CheckAlmostEqual(answer[i], out[i], 1.0e-6);
	}
	if (verbose) {
		PrintArray("data  ", num_data, in_data);
		PrintArray("out   ", ELEMENTSOF(answer), out);
		PrintArray("answer", ELEMENTSOF(answer), answer);
	}

	LIBSAKURA_SYMBOL (Status) destroy_status = sakura_DestroyBaselineContext(
			context);
	EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);

}

/*
 * Test GetBestFitBaselineCoefficientsSinusoid
 * erroneous cases: null pointer cases
 * parameters to be tested include context, data, mask, nwave, coeff, final_mask and baseline_status.
 */
TEST_F(BaselineWK, GetBestFitBaselineCoefficientsSinusoidErroneousCasesNullPointer) {
	enum NPItems {
		NP_kContext,
		NP_kData,
		NP_kMask,
		NP_kNwave,
		NP_kCoeff,
		NP_kFinalMask,
		NP_kBaselineStatus,
		NP_kNumElems
	};
	vector<string> np_param_names = { "context", "data", "mask", "nwave",
			"coeff", "final_mask", "baseline_status" };
	cout << "    Testing for ";

	size_t const num_data = 10;
	size_t const dummy = 1;
	size_t const context_nwave = 2;
	size_t const num_nwave = 3;

	for (NPItems item = static_cast<NPItems>(0); item < NP_kNumElems; item =
			static_cast<NPItems>(item + 1)) {
		cout << np_param_names[item] << ((item < NP_kNumElems - 1) ? ", " : "");
		size_t nwave[num_nwave] = { 0, 1, 2 };
		size_t num_coeff =
				(nwave[0] == 0) ? (2 * num_nwave - 1) : (2 * num_nwave);
		double coeff[num_coeff];
		SetDoubleConstant(1.0, ELEMENTSOF(coeff), coeff);
		SIMD_ALIGN
		float in_data[num_data];
		SetFloatSinusoidal(num_nwave, nwave, coeff, num_data, in_data);
		SIMD_ALIGN
		bool mask[ELEMENTSOF(in_data)];
		SetBoolConstant(true, ELEMENTSOF(in_data), mask);
		SIMD_ALIGN
		bool final_mask[ELEMENTSOF(in_data)];
		SIMD_ALIGN
		double out[ELEMENTSOF(coeff)];
		float rms;
		LIBSAKURA_SYMBOL(BaselineContext) *context = nullptr;
		LIBSAKURA_SYMBOL (Status) create_status = sakura_CreateBaselineContext(
				LIBSAKURA_SYMBOL(BaselineType_kSinusoid), dummy, dummy,
				context_nwave, num_data, &context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
		LIBSAKURA_SYMBOL(BaselineStatus) baseline_status;

		float *in_data_ptr = in_data;
		bool *mask_ptr = mask;
		size_t *nwave_ptr = nwave;
		bool *final_mask_ptr = final_mask;
		double *out_ptr = out;
		LIBSAKURA_SYMBOL(BaselineContext) *context_ptr = context;
		LIBSAKURA_SYMBOL(BaselineStatus) *baseline_status_ptr = &baseline_status;

		switch (item) {
		case NP_kData:
			in_data_ptr = nullptr;
			break;
		case NP_kMask:
			mask_ptr = nullptr;
			break;
		case NP_kNwave:
			nwave_ptr = nullptr;
			break;
		case NP_kCoeff:
			out_ptr = nullptr;
			break;
		case NP_kFinalMask:
			final_mask_ptr = nullptr;
			break;
		case NP_kContext:
			context_ptr = nullptr;
			break;
		case NP_kBaselineStatus:
			baseline_status_ptr = nullptr;
			break;
		default:
			assert(false);
		}

		LIBSAKURA_SYMBOL (Status) coeff_status =
		LIBSAKURA_SYMBOL(GetBestFitBaselineCoefficientsSinusoidFloat)(
				context_ptr, num_data, in_data_ptr, mask_ptr, 5.0f, 1,
				num_nwave, nwave_ptr, num_coeff, out_ptr, final_mask_ptr,
				&rms, baseline_status_ptr);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kInvalidArgument), coeff_status);

		LIBSAKURA_SYMBOL (Status) destroy_status =
				sakura_DestroyBaselineContext(context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);
	}
	cout << endl;
}

/*
 * Test GetBestFitBaselineCoefficientsSinusoid
 * erroneous cases: unaligned cases
 * parameters to be tested include data, mask, coeff and final_mask.
 */
TEST_F(BaselineWK, GetBestFitBaselineCoefficientsSinusoidErroneousCasesUnaligned) {
	enum UAItems {
		UA_kData, UA_kMask, UA_kCoeff, UA_kFinalMask, UA_kNumElems
	};
	vector<string> ua_param_names = { "data", "mask", "coeff", "final_mask" };
	cout << "    Testing for ";

	size_t const num_data = 10;
	size_t const dummy = 1;
	size_t const context_nwave = 2;
	size_t const num_nwave = 3;

	for (UAItems item = static_cast<UAItems>(0); item < UA_kNumElems; item =
			static_cast<UAItems>(item + 1)) {
		cout << ua_param_names[item] << ((item < UA_kNumElems - 1) ? ", " : "");
		size_t nwave[num_nwave] = { 0, 1, 2 };
		size_t num_coeff =
				(nwave[0] == 0) ? (2 * num_nwave - 1) : (2 * num_nwave);
		double coeff[num_coeff];
		SetDoubleConstant(1.0, ELEMENTSOF(coeff), coeff);
		SIMD_ALIGN
		float in_data[num_data + 1];
		SetFloatSinusoidal(num_nwave, nwave, coeff, num_data, in_data);
		SIMD_ALIGN
		bool mask[ELEMENTSOF(in_data)];
		SetBoolConstant(true, ELEMENTSOF(in_data), mask);
		SIMD_ALIGN
		bool final_mask[ELEMENTSOF(in_data)];
		SIMD_ALIGN
		double out[ELEMENTSOF(coeff) + 1];
		float rms;
		LIBSAKURA_SYMBOL(BaselineContext) *context = nullptr;
		LIBSAKURA_SYMBOL (Status) create_status = sakura_CreateBaselineContext(
				LIBSAKURA_SYMBOL(BaselineType_kSinusoid), dummy, dummy,
				context_nwave, num_data, &context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
		LIBSAKURA_SYMBOL(BaselineStatus) baseline_status;

		float *in_data_ptr = in_data;
		bool *mask_ptr = mask;
		bool *final_mask_ptr = final_mask;
		double *out_ptr = out;

		switch (item) {
		case UA_kData:
			++in_data_ptr;
			assert(!LIBSAKURA_SYMBOL(IsAligned)(in_data_ptr));
			break;
		case UA_kMask:
			++mask_ptr;
			assert(!LIBSAKURA_SYMBOL(IsAligned)(mask_ptr));
			break;
		case UA_kCoeff:
			++out_ptr;
			assert(!LIBSAKURA_SYMBOL(IsAligned)(out_ptr));
			break;
		case UA_kFinalMask:
			++final_mask_ptr;
			assert(!LIBSAKURA_SYMBOL(IsAligned)(final_mask_ptr));
			break;
		default:
			assert(false);
		}

		LIBSAKURA_SYMBOL (Status) coeff_status =
		LIBSAKURA_SYMBOL(GetBestFitBaselineCoefficientsSinusoidFloat)(context,
				num_data, in_data_ptr, mask_ptr, 5.0f, 1, num_nwave, nwave,
				num_coeff, out_ptr, final_mask_ptr, &rms, &baseline_status);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kInvalidArgument), coeff_status);

		LIBSAKURA_SYMBOL (Status) destroy_status =
				sakura_DestroyBaselineContext(context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);
	}
	cout << endl;
}

/*
 * Test GetBestFitBaselineCoefficientsSinusoid
 * erroneous cases: bad parameter value cases as follows:
 *     (1) num_data < context->num_bases
 *     (2) num_data < (!=) context->num_basis_data
 *     (3) num_data > (!=) context->num_basis_data
 *     (4) clip_threshold_sigma == 0
 *     (5) clip_threshold_sigma < 0
 *     (6) num_nwave == 0
 *     (7) nwave with duplicated elements
 *     (8) nwave with not in ascending order
 *     (9) maximum nwave to create context < maximum given nwave
 *     (10) num_coeff > context->num_bases
 */
TEST_F(BaselineWK, GetBestFitBaselineCoefficientsSinusoidErroneousCasesBadParameterValue) {
	enum BVItems {
		BV_kDataLTNumBases,
		BV_kDataLTNumBasisData,
		BV_kDataGTNumBasisData,
		BV_kClipThresholdZero,
		BV_kClipThresholdNegative,
		BV_kNumNWaveZero,
		BV_kNWaveDuplicated,
		BV_kNWaveNotAscending,
		BV_kGivenTooLargeMaximumNWave,
		BV_kNumCoeffGTNumBases,
		BV_kNumElems
	};
	vector<string> bv_param_names = { "(num_data < context->num_bases)",
			"(num_data < context->num_basis_data)",
			"(num_data > context->num_basis_data)",
			"(clip_threshold_sigma == 0)", "(clip_threshold_sigma < 0)",
			"(num_nwave == 0)", "(nwave duplicated)", "(nwave not ascending)",
			"(context_max_nwave < given_max_nwave)",
			"(num_coeff > context->num_bases)" };
	cout << "    Testing for cases " << endl;

	size_t const num_basis_data = 10;
	size_t const dummy = 1;
	size_t const context_nwave = 2;

	for (BVItems item = static_cast<BVItems>(0); item < BV_kNumElems; item =
			static_cast<BVItems>(item + 1)) {
		cout << "        " << bv_param_names[item]
				<< ((item < BV_kNumElems - 1) ? ", " : "") << endl;
		size_t num_data = num_basis_data;
		float clip_threshold_sigma = 5.0f;
		size_t num_nwave = 3;
		size_t nwave[num_nwave];
		for (size_t i = 0; i < num_nwave; ++i) {
			nwave[i] = i;
		}
		size_t tmp_nwave = nwave[0];
		size_t num_coeff = 5;
		size_t num_coeff_by_nwave =
				(nwave[0] == 0) ? (2 * num_nwave - 1) : (2 * num_nwave);

		switch (item) {
		case BV_kDataLTNumBases:
			num_data = 2;
			break;
		case BV_kDataLTNumBasisData:
			num_data = 5;
			break;
		case BV_kDataGTNumBasisData:
			num_data = 15;
			break;
		case BV_kClipThresholdZero:
			clip_threshold_sigma = 0.0f;
			break;
		case BV_kClipThresholdNegative:
			clip_threshold_sigma = -5.0f;
			break;
		case BV_kNumNWaveZero:
			num_nwave = 0;
			break;
		case BV_kNWaveDuplicated:
			nwave[1] = nwave[0];
			break;
		case BV_kNWaveNotAscending:
			tmp_nwave = nwave[1];
			nwave[1] = nwave[0];
			nwave[0] = tmp_nwave;
			break;
		case BV_kGivenTooLargeMaximumNWave:
			nwave[num_nwave-1] = context_nwave + 10;
			break;
		case BV_kNumCoeffGTNumBases:
			num_coeff = num_coeff_by_nwave + 1;
			break;
		default:
			assert(false);
		}

		double coeff[num_coeff];
		SetDoubleConstant(1.0, ELEMENTSOF(coeff), coeff);
		SIMD_ALIGN
		float in_data[num_data];
		SetFloatSinusoidal(num_nwave, nwave, coeff, num_data, in_data);
		SIMD_ALIGN
		bool mask[ELEMENTSOF(in_data)];
		SetBoolConstant(true, ELEMENTSOF(in_data), mask);
		SIMD_ALIGN
		bool final_mask[ELEMENTSOF(in_data)];
		SIMD_ALIGN
		double out[ELEMENTSOF(coeff)];
		float rms;
		LIBSAKURA_SYMBOL(BaselineContext) *context = nullptr;
		LIBSAKURA_SYMBOL (Status) create_status = sakura_CreateBaselineContext(
				LIBSAKURA_SYMBOL(BaselineType_kSinusoid), dummy, dummy,
				context_nwave, num_basis_data, &context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
		LIBSAKURA_SYMBOL(BaselineStatus) baseline_status;

		LIBSAKURA_SYMBOL (Status) coeff_status =
		LIBSAKURA_SYMBOL(GetBestFitBaselineCoefficientsSinusoidFloat)(context,
				num_data, in_data, mask, clip_threshold_sigma, 1, num_nwave,
				nwave, num_coeff, out, final_mask, &rms, &baseline_status);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kInvalidArgument), coeff_status);

		LIBSAKURA_SYMBOL (Status) destroy_status =
				sakura_DestroyBaselineContext(context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);
	}
}

/*
 * Test SubtractBaselineSinusoid
 * successful cases
 * compute the best-fit sinusoidal baseline and subtract it
 * context is created with maximum nwave of 2 in all cases, that is,
 * context contains bases with nwave of 0(constant), 1(sin/cos)
 * and 2(sin/cos).
 * test cases: all combinations of nwave between 0 and 2.
 */
TEST_F(BaselineWK, SubtractBaselineSinusoidSuccessfulCase) {
	size_t const dummy = 1;
	size_t const context_nwave = 3;
	size_t const num_nwave_set = 4;
	size_t const nwave_set_length[num_nwave_set] = { 4, 6, 4, 1 };
	size_t nwave_set1[4][1] = { { 0 }, { 1 }, { 2 }, { 3 } };
	size_t nwave_set2[6][2] = { { 0, 1 }, { 0, 2 }, { 0, 3 }, { 1, 2 },
			{ 1, 3 }, { 2, 3 } };
	size_t nwave_set3[4][3] = { { 0, 1, 2 }, { 0, 1, 3 }, { 0, 2, 3 },
			{ 1, 2, 3 } };
	size_t nwave_set4[1][4] = { { 0, 1, 2, 3 } };
	cout << "    Baseline context has sinusoidal bases with nwave up to 3..."
			<< endl;

	for (size_t num_nwave = 1; num_nwave <= num_nwave_set; ++num_nwave) {
		cout << "    Testing for num_nwave = " << num_nwave << ": nwave = ";

		size_t const num_cases = nwave_set_length[num_nwave - 1];
		size_t nwave[num_nwave];
		for (size_t j = 0; j < num_cases; ++j) {
			cout << "{";
			for (size_t k = 0; k < num_nwave; ++k) {
				if (num_nwave == 1) {
					nwave[k] = nwave_set1[j][k];
				} else if (num_nwave == 2) {
					nwave[k] = nwave_set2[j][k];
				} else if (num_nwave == 3) {
					nwave[k] = nwave_set3[j][k];
				} else if (num_nwave == 4) {
					nwave[k] = nwave_set4[j][k];
				}
				cout << nwave[k];
				if (k < num_nwave - 1) {
					cout << ", ";
				}
			}
			cout << "}";
			if (j < num_cases - 1) {
				cout << ", ";
			}
			size_t num_coeff =
					(nwave[0] == 0) ? (2 * num_nwave - 1) : (2 * num_nwave);
			double coeff[num_coeff];
			SetDoubleConstant(1.0, num_coeff, coeff);
			size_t const num_data = NUM_DATA2;
			SIMD_ALIGN
			float in_data[num_data];
			SetFloatSinusoidal(num_nwave, nwave, coeff, num_data, in_data);
			SIMD_ALIGN
			bool mask[ELEMENTSOF(in_data)];
			SetBoolConstant(true, ELEMENTSOF(in_data), mask);
			LIBSAKURA_SYMBOL(BaselineContext) * context = nullptr;
			LIBSAKURA_SYMBOL (Status) create_status =
					sakura_CreateBaselineContext(
							LIBSAKURA_SYMBOL(BaselineType_kSinusoid), dummy,
							dummy, context_nwave, num_data, &context);
			EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
			SIMD_ALIGN
			float out[ELEMENTSOF(in_data)];
			float answer[ELEMENTSOF(in_data)];
			for (size_t i = 0; i < ELEMENTSOF(coeff); ++i) {
				SetFloatConstant(0.0f, ELEMENTSOF(answer), answer);
			}
			float rms;
			LIBSAKURA_SYMBOL(BaselineStatus) baseline_status;
			LIBSAKURA_SYMBOL (Status) sub_status =
			LIBSAKURA_SYMBOL(SubtractBaselineSinusoidFloat)(context, num_nwave,
					nwave, num_data, in_data, mask, 5.0f, 1,
					true, mask, out, &rms, &baseline_status);
			EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), sub_status);
			EXPECT_EQ(LIBSAKURA_SYMBOL(BaselineStatus_kOK), baseline_status);

			for (size_t i = 0; i < ELEMENTSOF(answer); ++i) {
				CheckAlmostEqual(answer[i], out[i], 1.0e-6);
			}
			if (verbose) {
				PrintArray("data  ", num_data, in_data);
				PrintArray("out   ", ELEMENTSOF(answer), out);
				PrintArray("answer", ELEMENTSOF(answer), answer);
			}

			LIBSAKURA_SYMBOL (Status) destroy_status =
					sakura_DestroyBaselineContext(context);
			EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);

		}
		cout << endl;
	}
}

/*
 * Test SubtractBaselineSinusoid
 * successful cases with masked data
 */
TEST_F(BaselineWK, SubtractBaselineSinusoidSuccessfulCaseWithMaskedData) {
	size_t const num_data = NUM_DATA2;
	size_t const dummy = 1;
	size_t const context_nwave = 2;
	size_t const num_nwave = 3;
	size_t nwave[num_nwave] = { 0, 1, 2 };
	size_t num_coeff = (nwave[0] == 0) ? (2 * num_nwave - 1) : (2 * num_nwave);
	double coeff[num_coeff];
	SetDoubleConstant(1.0, num_coeff, coeff);
	SIMD_ALIGN
	float in_data[num_data];
	SetFloatSinusoidal(num_nwave, nwave, coeff, num_data, in_data);
	SIMD_ALIGN
	bool mask[ELEMENTSOF(in_data)];
	SetBoolConstant(true, ELEMENTSOF(in_data), mask);
	LIBSAKURA_SYMBOL(BaselineContext) * context = nullptr;
	LIBSAKURA_SYMBOL (Status) create_status = sakura_CreateBaselineContext(
			LIBSAKURA_SYMBOL(BaselineType_kSinusoid), dummy, dummy,
			context_nwave, num_data, &context);
	EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
	SIMD_ALIGN
	float out[ELEMENTSOF(in_data)];
	float answer[ELEMENTSOF(in_data)];
	for (size_t i = 0; i < ELEMENTSOF(coeff); ++i) {
		SetFloatConstant(0.0f, ELEMENTSOF(answer), answer);
	}
	float rms;
	LIBSAKURA_SYMBOL(BaselineStatus) baseline_status;
	LIBSAKURA_SYMBOL (Status) sub_status;
	for (size_t i = 0; i < 4; ++i) {
		size_t num_masked_idx = 1;
		if (i == 3) num_masked_idx = 2;
		size_t masked_idx[num_masked_idx];
		if (i == 0) { // masked at about the middle
			masked_idx[0] = ELEMENTSOF(in_data)/2;
		} else if (i == 1) { // masked at left edge
			masked_idx[0] = 0;
		} else if (i == 2) { // masked at right edge
			masked_idx[0] = ELEMENTSOF(in_data)-1;
		} else if (i == 3) { // masked at both edges
			masked_idx[0] = 0;
			masked_idx[1] = ELEMENTSOF(in_data)-1;
		}
		for (size_t j = 0; j < num_masked_idx; ++j) {
			mask[masked_idx[j]] = false;
			in_data[masked_idx[j]] = 10.0; // spike, which should not affect the fitting result
		}
		sub_status = LIBSAKURA_SYMBOL(SubtractBaselineSinusoidFloat)(context,
				num_nwave, nwave, num_data, in_data, mask, 5.0f, 1, true, mask,
				out, &rms, &baseline_status);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), sub_status);
		EXPECT_EQ(LIBSAKURA_SYMBOL(BaselineStatus_kOK), baseline_status);
		for (size_t k = 0; k < ELEMENTSOF(answer); ++k) {
			if (mask[k]) {
				CheckAlmostEqual(answer[k], out[k], 5.0e-6);
			}
		}
	}

	if (verbose) {
		PrintArray("data  ", num_data, in_data);
		PrintArray("out   ", ELEMENTSOF(answer), out);
		PrintArray("answer", ELEMENTSOF(answer), answer);
	}

	LIBSAKURA_SYMBOL (Status) destroy_status = sakura_DestroyBaselineContext(
			context);
	EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);

}

/*
 * Test SubtractBaselineSinusoid
 * time-consuming successful case for performance measurement
 */
TEST_F(BaselineWK, SubtractBaselineSinusoidPerformanceTest) {
	size_t const num_repeat = 100;
	size_t const num_data = 50000;
	size_t const dummy = 1;
	size_t const context_nwave = 10;
	size_t const num_nwave = 10;
	size_t nwave[num_nwave] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
	size_t num_coeff = (nwave[0] == 0) ? (2 * num_nwave - 1) : (2 * num_nwave);
	double coeff[num_coeff];
	SetDoubleConstant(1.0, num_coeff, coeff);
	SIMD_ALIGN
	float in_data[num_data];
	SetFloatSinusoidal(num_nwave, nwave, coeff, num_data, in_data);
	SIMD_ALIGN
	bool mask[ELEMENTSOF(in_data)];
	SetBoolConstant(true, ELEMENTSOF(in_data), mask);
	LIBSAKURA_SYMBOL(BaselineContext) * context = nullptr;
	LIBSAKURA_SYMBOL (Status) create_status = sakura_CreateBaselineContext(
			LIBSAKURA_SYMBOL(BaselineType_kSinusoid), dummy, dummy,
			context_nwave, num_data, &context);
	EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
	SIMD_ALIGN
	float out[ELEMENTSOF(in_data)];
	float answer[ELEMENTSOF(in_data)];
	for (size_t i = 0; i < ELEMENTSOF(coeff); ++i) {
		SetFloatConstant(0.0f, ELEMENTSOF(answer), answer);
	}
	float rms;
	LIBSAKURA_SYMBOL(BaselineStatus) baseline_status;
	LIBSAKURA_SYMBOL (Status) sub_status;
	double start_time = sakura_GetCurrentTime();
	for (size_t i = 0; i < num_repeat; ++i) {
		sub_status = LIBSAKURA_SYMBOL(SubtractBaselineSinusoidFloat)(context,
				num_nwave, nwave, num_data, in_data, mask, 5.0f, 1, true, mask,
				out, &rms, &baseline_status);
	}
	double end_time = sakura_GetCurrentTime();
	std::cout << std::setprecision(5)
			<< "#x# benchmark BaselineWK_SubtractBaselineSinusoidPerformanceTest"
			<< " " << (end_time - start_time) << std::endl;
	EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), sub_status);
	EXPECT_EQ(LIBSAKURA_SYMBOL(BaselineStatus_kOK), baseline_status);

	for (size_t i = 0; i < ELEMENTSOF(answer); ++i) {
		CheckAlmostEqual(answer[i], out[i], 5.0e-6);
	}
	if (verbose) {
		PrintArray("data  ", num_data, in_data);
		PrintArray("out   ", ELEMENTSOF(answer), out);
		PrintArray("answer", ELEMENTSOF(answer), answer);
	}

	LIBSAKURA_SYMBOL (Status) destroy_status = sakura_DestroyBaselineContext(
			context);
	EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);

}

/*
 * Test SubtractBaselineSinusoid
 * erroneous cases: null pointer cases
 * parameters to be tested include context, data, mask, nwave, coeff, final_mask and baseline_status.
 */
TEST_F(BaselineWK, SubtractBaselineSinusoidErroneousCasesNullPointer) {
	enum NPItems {
		NP_kContext,
		NP_kNwave,
		NP_kData,
		NP_kMask,
		NP_kFinalMask,
		NP_kOut,
		NP_kBaselineStatus,
		NP_kNumElems
	};
	vector<string> np_param_names = { "context", "nwave", "data", "mask",
			"final_mask", "out", "baseline_status" };
	cout << "    Testing for ";

	size_t const num_data = 10;
	size_t const dummy = 1;
	size_t const context_nwave = 2;
	size_t const num_nwave = 3;

	for (NPItems item = static_cast<NPItems>(0); item < NP_kNumElems; item =
			static_cast<NPItems>(item + 1)) {
		cout << np_param_names[item] << ((item < NP_kNumElems - 1) ? ", " : "");
		size_t nwave[num_nwave] = { 0, 1, 2 };
		size_t num_coeff =
				(nwave[0] == 0) ? (2 * num_nwave - 1) : (2 * num_nwave);
		double coeff[num_coeff];
		SetDoubleConstant(1.0, ELEMENTSOF(coeff), coeff);
		SIMD_ALIGN
		float in_data[num_data];
		SetFloatSinusoidal(num_nwave, nwave, coeff, num_data, in_data);
		SIMD_ALIGN
		bool mask[ELEMENTSOF(in_data)];
		SetBoolConstant(true, ELEMENTSOF(in_data), mask);
		SIMD_ALIGN
		bool final_mask[ELEMENTSOF(in_data)];
		SIMD_ALIGN
		float out[ELEMENTSOF(in_data)];
		float rms;
		LIBSAKURA_SYMBOL(BaselineContext) *context = nullptr;
		LIBSAKURA_SYMBOL (Status) create_status = sakura_CreateBaselineContext(
				LIBSAKURA_SYMBOL(BaselineType_kSinusoid), dummy, dummy,
				context_nwave, num_data, &context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
		LIBSAKURA_SYMBOL(BaselineStatus) baseline_status;

		float *in_data_ptr = in_data;
		bool *mask_ptr = mask;
		size_t *nwave_ptr = nwave;
		bool *final_mask_ptr = final_mask;
		float *out_ptr = out;
		LIBSAKURA_SYMBOL(BaselineContext) *context_ptr = context;
		LIBSAKURA_SYMBOL(BaselineStatus) *baseline_status_ptr = &baseline_status;

		switch (item) {
		case NP_kData:
			in_data_ptr = nullptr;
			break;
		case NP_kMask:
			mask_ptr = nullptr;
			break;
		case NP_kNwave:
			nwave_ptr = nullptr;
			break;
		case NP_kOut:
			out_ptr = nullptr;
			break;
		case NP_kFinalMask:
			final_mask_ptr = nullptr;
			break;
		case NP_kContext:
			context_ptr = nullptr;
			break;
		case NP_kBaselineStatus:
			baseline_status_ptr = nullptr;
			break;
		default:
			assert(false);
		}

		LIBSAKURA_SYMBOL (Status) sub_status =
		LIBSAKURA_SYMBOL(SubtractBaselineSinusoidFloat)(context_ptr, num_nwave,
				nwave_ptr, num_data, in_data_ptr, mask_ptr, 5.0f, 1, true,
				final_mask_ptr, out_ptr, &rms, baseline_status_ptr);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kInvalidArgument), sub_status);

		LIBSAKURA_SYMBOL (Status) destroy_status =
				sakura_DestroyBaselineContext(context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);
	}
	cout << endl;
}

/*
 * Test SubtractBaselineSinusoidFloat
 * erroneous cases: unaligned cases
 * parameters to be tested include data, mask, final_mask and out
 */
TEST_F(BaselineWK, SubtractBaselineSinusoidErroneousCasesUnaligned) {
	enum UAItems {
		UA_kData, UA_kMask, UA_kFinalMask, UA_kOut, UA_kNumElems
	};
	vector<string> ua_param_names = { "data", "mask", "final_mask", "out" };
	cout << "    Testing for ";

	size_t const num_data = 10;
	size_t const dummy = 1;
	size_t const context_nwave = 2;
	size_t const num_nwave = 3;

	for (UAItems item = static_cast<UAItems>(0); item < UA_kNumElems; item =
			static_cast<UAItems>(item + 1)) {
		cout << ua_param_names[item] << ((item < UA_kNumElems - 1) ? ", " : "");
		size_t nwave[num_nwave] = { 0, 1, 2 };
		size_t num_coeff =
				(nwave[0] == 0) ? (2 * num_nwave - 1) : (2 * num_nwave);
		double coeff[num_coeff];
		SetDoubleConstant(1.0, ELEMENTSOF(coeff), coeff);
		SIMD_ALIGN
		float in_data[num_data + 1];
		SetFloatSinusoidal(num_nwave, nwave, coeff, num_data, in_data);
		SIMD_ALIGN
		bool mask[ELEMENTSOF(in_data)];
		SetBoolConstant(true, ELEMENTSOF(in_data), mask);
		SIMD_ALIGN
		bool final_mask[ELEMENTSOF(in_data)];
		SIMD_ALIGN
		float out[ELEMENTSOF(in_data)];
		float rms;
		LIBSAKURA_SYMBOL(BaselineContext) *context = nullptr;
		LIBSAKURA_SYMBOL (Status) create_status = sakura_CreateBaselineContext(
				LIBSAKURA_SYMBOL(BaselineType_kSinusoid), dummy, dummy,
				context_nwave, num_data, &context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
		LIBSAKURA_SYMBOL(BaselineStatus) baseline_status;

		float *in_data_ptr = in_data;
		bool *mask_ptr = mask;
		bool *final_mask_ptr = final_mask;
		float *out_ptr = out;

		switch (item) {
		case UA_kData:
			++in_data_ptr;
			assert(!LIBSAKURA_SYMBOL(IsAligned)(in_data_ptr));
			break;
		case UA_kMask:
			++mask_ptr;
			assert(!LIBSAKURA_SYMBOL(IsAligned)(mask_ptr));
			break;
		case UA_kFinalMask:
			++final_mask_ptr;
			assert(!LIBSAKURA_SYMBOL(IsAligned)(final_mask_ptr));
			break;
		case UA_kOut:
			++out_ptr;
			assert(!LIBSAKURA_SYMBOL(IsAligned)(out_ptr));
			break;
		default:
			assert(false);
		}

		LIBSAKURA_SYMBOL(Status) sub_status =
		LIBSAKURA_SYMBOL(SubtractBaselineSinusoidFloat)(context, num_nwave,
				nwave, num_data, in_data_ptr, mask_ptr, 5.0f, 1, true,
				final_mask_ptr, out_ptr, &rms, &baseline_status);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kInvalidArgument), sub_status);

		LIBSAKURA_SYMBOL (Status) destroy_status =
				sakura_DestroyBaselineContext(context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);
	}
	cout << endl;
}

/*
 * Test SubtractBaselineSinusoidFloat
 * erroneous cases: bad parameter value cases as follows:
 *     (1) num_data < context->num_bases
 *     (2) num_data < (!=) context->num_basis_data
 *     (3) num_data > (!=) context->num_basis_data
 *     (4) clip_threshold_sigma == 0
 *     (5) clip_threshold_sigma < 0
 *     (6) num_nwave == 0
 *     (7) nwave with duplicated elements
 *     (8) nwave with not in ascending order
 *     (9) max_nwave in context < given max_nwave
 *     (10) num_bases computed for given nwave > context->num_bases
 */
TEST_F(BaselineWK, SubtractBaselineSinusoidErroneousCasesBadParameterValue) {
	enum BVItems {
		BV_kDataLTNumBases,
		BV_kDataLTNumBasisData,
		BV_kDataGTNumBasisData,
		BV_kClipThresholdZero,
		BV_kClipThresholdNegative,
		BV_kNumNWaveZero,
		BV_kNWaveDuplicated,
		BV_kNWaveNotAscending,
		BV_kGivenTooLargeMaximumNWave,
		BV_kNumBasesByNWaveGTNumBases,
		BV_kNumElems
	};
	vector<string> bv_param_names = { "(num_data < context->num_bases)",
			"(num_data < context->num_basis_data)",
			"(num_data > context->num_basis_data)",
			"(clip_threshold_sigma == 0)", "(clip_threshold_sigma < 0)",
			"(num_nwave == 0)", "(nwave duplicated)", "(nwave not ascending)",
			"(context_max_nwave < given_max_nwave)",
			"(num_bases by given nwave > context->num_bases)" };
	cout << "    Testing for cases " << endl;

	size_t const num_basis_data = 10;
	size_t const dummy = 1;

	for (BVItems item = static_cast<BVItems>(0); item < BV_kNumElems; item =
			static_cast<BVItems>(item + 1)) {
		cout << "        " << bv_param_names[item]
				<< ((item < BV_kNumElems - 1) ? ", " : "") << endl;
		size_t num_data = num_basis_data;
		float clip_threshold_sigma = 5.0f;
		size_t context_nwave = 2;
		size_t num_nwave = 3;
		size_t nwave[num_nwave];
		for (size_t i = 0; i < num_nwave; ++i) {
			nwave[i] = i;
		}
		size_t tmp_nwave = nwave[0];
		size_t num_coeff = 5;

		switch (item) {
		case BV_kDataLTNumBases:
			num_data = 2;
			break;
		case BV_kDataLTNumBasisData:
			num_data = 5;
			break;
		case BV_kDataGTNumBasisData:
			num_data = 15;
			break;
		case BV_kClipThresholdZero:
			clip_threshold_sigma = 0.0f;
			break;
		case BV_kClipThresholdNegative:
			clip_threshold_sigma = -5.0f;
			break;
		case BV_kNumNWaveZero:
			num_nwave = 0;
			break;
		case BV_kNWaveDuplicated:
			nwave[1] = nwave[0];
			break;
		case BV_kNWaveNotAscending:
			tmp_nwave = nwave[1];
			nwave[1] = nwave[0];
			nwave[0] = tmp_nwave;
			break;
		case BV_kGivenTooLargeMaximumNWave:
			nwave[num_nwave-1] = context_nwave + 10;
			break;
		case BV_kNumBasesByNWaveGTNumBases:
			context_nwave = 1;
			break;
		default:
			assert(false);
		}

		double coeff[num_coeff];
		SetDoubleConstant(1.0, ELEMENTSOF(coeff), coeff);
		SIMD_ALIGN
		float in_data[num_data];
		SetFloatSinusoidal(num_nwave, nwave, coeff, num_data, in_data);
		SIMD_ALIGN
		bool mask[ELEMENTSOF(in_data)];
		SetBoolConstant(true, ELEMENTSOF(in_data), mask);
		SIMD_ALIGN
		bool final_mask[ELEMENTSOF(in_data)];
		SIMD_ALIGN
		float out[ELEMENTSOF(in_data)];
		float rms;
		LIBSAKURA_SYMBOL(BaselineContext) *context = nullptr;
		LIBSAKURA_SYMBOL (Status) create_status = sakura_CreateBaselineContext(
				LIBSAKURA_SYMBOL(BaselineType_kSinusoid), dummy, dummy,
				context_nwave, num_basis_data, &context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
		LIBSAKURA_SYMBOL(BaselineStatus) baseline_status;

		LIBSAKURA_SYMBOL(Status) sub_status =
		LIBSAKURA_SYMBOL(SubtractBaselineSinusoidFloat)(context, num_nwave,
				nwave, num_data, in_data, mask, clip_threshold_sigma, 1, true,
				final_mask, out, &rms, &baseline_status);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kInvalidArgument), sub_status);

		LIBSAKURA_SYMBOL (Status) destroy_status =
				sakura_DestroyBaselineContext(context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);
	}
}

/*
 * Test SubtractBaselineSinusoidUsingCoefficientsFloat
 * successful cases
 * subtract sinusoidal baseline with given coefficients
 * context is created with maximum nwave of 2 in all cases, that is,
 * context contains bases with nwave of 0(constant), 1(sin/cos)
 * and 2(sin/cos).
 * test cases: all combinations of nwave between 0 and 2.
 */
TEST_F(BaselineWK, SubtractBaselineSinusoidUsingCoefficientsFloatSuccessfulCase) {
	size_t const dummy = 1;
	size_t const context_nwave = 3;
	size_t const num_nwave_set = 4;
	size_t const nwave_set_length[num_nwave_set] = { 4, 6, 4, 1 };
	size_t nwave_set1[4][1] = { { 0 }, { 1 }, { 2 }, { 3 } };
	size_t nwave_set2[6][2] = { { 0, 1 }, { 0, 2 }, { 0, 3 }, { 1, 2 },
			{ 1, 3 }, { 2, 3 } };
	size_t nwave_set3[4][3] = { { 0, 1, 2 }, { 0, 1, 3 }, { 0, 2, 3 },
			{ 1, 2, 3 } };
	size_t nwave_set4[1][4] = { { 0, 1, 2, 3 } };
	cout << "    Baseline context has sinusoidal bases with nwave up to 3..."
			<< endl;

	for (size_t num_nwave = 1; num_nwave <= num_nwave_set; ++num_nwave) {
		cout << "    Testing for num_nwave = " << num_nwave << ": nwave = ";

		size_t const num_cases = nwave_set_length[num_nwave - 1];
		size_t nwave[num_nwave];
		for (size_t j = 0; j < num_cases; ++j) {
			cout << "{";
			for (size_t k = 0; k < num_nwave; ++k) {
				if (num_nwave == 1) {
					nwave[k] = nwave_set1[j][k];
				} else if (num_nwave == 2) {
					nwave[k] = nwave_set2[j][k];
				} else if (num_nwave == 3) {
					nwave[k] = nwave_set3[j][k];
				} else if (num_nwave == 4) {
					nwave[k] = nwave_set4[j][k];
				}
				cout << nwave[k];
				if (k < num_nwave - 1) {
					cout << ", ";
				}
			}
			cout << "}";
			if (j < num_cases - 1) {
				cout << ", ";
			}
			size_t num_coeff =
					(nwave[0] == 0) ? (2 * num_nwave - 1) : (2 * num_nwave);
			SIMD_ALIGN
			double coeff[num_coeff];
			SetDoubleConstant(1.0, num_coeff, coeff);
			size_t const num_data = NUM_DATA2;
			SIMD_ALIGN
			float in_data[num_data];
			SetFloatSinusoidal(num_nwave, nwave, coeff, num_data, in_data);
			SIMD_ALIGN
			bool mask[ELEMENTSOF(in_data)];
			SetBoolConstant(true, ELEMENTSOF(in_data), mask);
			LIBSAKURA_SYMBOL(BaselineContext) * context = nullptr;
			LIBSAKURA_SYMBOL (Status) create_status =
					sakura_CreateBaselineContext(
							LIBSAKURA_SYMBOL(BaselineType_kSinusoid), dummy,
							dummy, context_nwave, num_data, &context);
			EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
			SIMD_ALIGN
			float out[ELEMENTSOF(in_data)];
			float answer[ELEMENTSOF(in_data)];
			for (size_t i = 0; i < ELEMENTSOF(coeff); ++i) {
				SetFloatConstant(0.0f, ELEMENTSOF(answer), answer);
			}
			LIBSAKURA_SYMBOL (Status) sub_status =
			LIBSAKURA_SYMBOL(SubtractBaselineSinusoidUsingCoefficientsFloat)(
					context, num_data, in_data, num_nwave, nwave, num_coeff,
					coeff, out);
			EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), sub_status);

			for (size_t i = 0; i < ELEMENTSOF(answer); ++i) {
				CheckAlmostEqual(answer[i], out[i], 1.0e-6);
			}
			if (verbose) {
				PrintArray("data  ", num_data, in_data);
				PrintArray("out   ", ELEMENTSOF(answer), out);
				PrintArray("answer", ELEMENTSOF(answer), answer);
			}

			LIBSAKURA_SYMBOL (Status) destroy_status =
					sakura_DestroyBaselineContext(context);
			EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);

		}
		cout << endl;
	}
}

/*
 * Test SubtractBaselineSinusoidUsingCoefficientsFloat
 * time-consuming successful case for performance measurement
 */
TEST_F(BaselineWK, SubtractBaselineSinusoidUsingCoefficientsPerformanceTest) {
	size_t const num_repeat = 2000;
	size_t const num_data = 50000;
	size_t const dummy = 1;
	size_t const context_nwave = 10;
	size_t const num_nwave = 10;
	size_t nwave[num_nwave] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
	size_t num_coeff = (nwave[0] == 0) ? (2 * num_nwave - 1) : (2 * num_nwave);
	double coeff[num_coeff];
	SetDoubleConstant(1.0, num_coeff, coeff);
	SIMD_ALIGN
	float in_data[num_data];
	SetFloatSinusoidal(num_nwave, nwave, coeff, num_data, in_data);
	SIMD_ALIGN
	bool mask[ELEMENTSOF(in_data)];
	SetBoolConstant(true, ELEMENTSOF(in_data), mask);
	LIBSAKURA_SYMBOL(BaselineContext) * context = nullptr;
	LIBSAKURA_SYMBOL (Status) create_status = sakura_CreateBaselineContext(
			LIBSAKURA_SYMBOL(BaselineType_kSinusoid), dummy, dummy,
			context_nwave, num_data, &context);
	EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);
	SIMD_ALIGN
	float out[ELEMENTSOF(in_data)];
	float answer[ELEMENTSOF(in_data)];
	for (size_t i = 0; i < ELEMENTSOF(coeff); ++i) {
		SetFloatConstant(0.0f, ELEMENTSOF(answer), answer);
	}
	LIBSAKURA_SYMBOL (Status) sub_status;
	double start_time = sakura_GetCurrentTime();
	for (size_t i = 0; i < num_repeat; ++i) {
		sub_status =
		LIBSAKURA_SYMBOL(SubtractBaselineSinusoidUsingCoefficientsFloat)(
				context, num_data, in_data, num_nwave, nwave, num_coeff, coeff,
				out);
	}
	double end_time = sakura_GetCurrentTime();
	std::cout << std::setprecision(5)
			<< "#x# benchmark BaselineWK_SubtractBaselineSinusoidUsingCoefficientsPerformanceTest"
			<< " " << (end_time - start_time) << std::endl;
	EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), sub_status);

	for (size_t i = 0; i < ELEMENTSOF(answer); ++i) {
		CheckAlmostEqual(answer[i], out[i], 5.0e-6);
	}
	if (verbose) {
		PrintArray("data  ", num_data, in_data);
		PrintArray("out   ", ELEMENTSOF(answer), out);
		PrintArray("answer", ELEMENTSOF(answer), answer);
	}

	LIBSAKURA_SYMBOL (Status) destroy_status = sakura_DestroyBaselineContext(
			context);
	EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);

}

/*
 * Test SubtractBaselineSinusoidUsingCoefficients
 * erroneous cases: null pointer cases
 * parameters to be tested include context, data, nwave, coeff, and out.
 */
TEST_F(BaselineWK, SubtractBaselineSinusoidUsingCoefficientsErroneousCasesNullPointer) {
	enum NPItems {
		NP_kContext, NP_kData, NP_kNwave, NP_kCoeff, NP_kOut, NP_kNumElems
	};
	vector<string> np_param_names =
			{ "context", "data", "nwave", "coeff", "out" };
	cout << "    Testing for ";

	size_t const num_data = 10;
	size_t const dummy = 1;
	size_t const context_nwave = 2;
	size_t const num_nwave = 3;

	for (NPItems item = static_cast<NPItems>(0); item < NP_kNumElems; item =
			static_cast<NPItems>(item + 1)) {
		cout << np_param_names[item] << ((item < NP_kNumElems - 1) ? ", " : "");
		size_t nwave[num_nwave] = { 0, 1, 2 };
		size_t num_coeff =
				(nwave[0] == 0) ? (2 * num_nwave - 1) : (2 * num_nwave);
		SIMD_ALIGN
		double coeff[num_coeff];
		SetDoubleConstant(1.0, ELEMENTSOF(coeff), coeff);
		SIMD_ALIGN
		float in_data[num_data];
		SetFloatSinusoidal(num_nwave, nwave, coeff, num_data, in_data);
		SIMD_ALIGN
		float out[ELEMENTSOF(in_data)];
		LIBSAKURA_SYMBOL(BaselineContext) *context = nullptr;
		LIBSAKURA_SYMBOL (Status) create_status = sakura_CreateBaselineContext(
				LIBSAKURA_SYMBOL(BaselineType_kSinusoid), dummy, dummy,
				context_nwave, num_data, &context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);

		float *in_data_ptr = in_data;
		size_t *nwave_ptr = nwave;
		double *coeff_ptr = coeff;
		float *out_ptr = out;
		LIBSAKURA_SYMBOL(BaselineContext) *context_ptr = context;

		switch (item) {
		case NP_kContext:
			context_ptr = nullptr;
			break;
		case NP_kData:
			in_data_ptr = nullptr;
			break;
		case NP_kNwave:
			nwave_ptr = nullptr;
			break;
		case NP_kCoeff:
			coeff_ptr = nullptr;
			break;
		case NP_kOut:
			out_ptr = nullptr;
			break;
		default:
			assert(false);
		}

		LIBSAKURA_SYMBOL (Status) sub_status =
		LIBSAKURA_SYMBOL(SubtractBaselineSinusoidUsingCoefficientsFloat)(
				context_ptr, num_data, in_data_ptr, num_nwave, nwave_ptr,
				num_coeff, coeff_ptr, out_ptr);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kInvalidArgument), sub_status);

		LIBSAKURA_SYMBOL (Status) destroy_status =
				sakura_DestroyBaselineContext(context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);
	}
	cout << endl;
}

/*
 * Test SubtractBaselineSinusoidUsingCoefficients
 * erroneous cases: unaligned cases
 * parameters to be tested include data, coeff and out
 */
TEST_F(BaselineWK, SubtractBaselineSinusoidUsingCoefficientsErroneousCasesUnaligned) {
	enum UAItems {
		UA_kData, UA_kCoeff, UA_kOut, UA_kNumElems
	};
	vector<string> ua_param_names = { "data", "coeff", "out" };
	cout << "    Testing for ";

	size_t const num_data = 10;
	size_t const dummy = 1;
	size_t const context_nwave = 2;
	size_t const num_nwave = 3;

	for (UAItems item = static_cast<UAItems>(0); item < UA_kNumElems; item =
			static_cast<UAItems>(item + 1)) {
		cout << ua_param_names[item] << ((item < UA_kNumElems - 1) ? ", " : "");
		size_t nwave[num_nwave] = { 0, 1, 2 };
		size_t num_coeff =
				(nwave[0] == 0) ? (2 * num_nwave - 1) : (2 * num_nwave);
		SIMD_ALIGN
		double coeff[num_coeff + 1];
		SetDoubleConstant(1.0, ELEMENTSOF(coeff), coeff);
		SIMD_ALIGN
		float in_data[num_data + 1];
		SetFloatSinusoidal(num_nwave, nwave, coeff, num_data, in_data);
		SIMD_ALIGN
		float out[ELEMENTSOF(in_data)];
		LIBSAKURA_SYMBOL(BaselineContext) *context = nullptr;
		LIBSAKURA_SYMBOL (Status) create_status = sakura_CreateBaselineContext(
				LIBSAKURA_SYMBOL(BaselineType_kSinusoid), dummy, dummy,
				context_nwave, num_data, &context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);

		float *in_data_ptr = in_data;
		double *coeff_ptr = coeff;
		float *out_ptr = out;

		switch (item) {
		case UA_kData:
			++in_data_ptr;
			assert(!LIBSAKURA_SYMBOL(IsAligned)(in_data_ptr));
			break;
		case UA_kCoeff:
			++coeff_ptr;
			assert(!LIBSAKURA_SYMBOL(IsAligned)(coeff_ptr));
			break;
		case UA_kOut:
			++out_ptr;
			assert(!LIBSAKURA_SYMBOL(IsAligned)(out_ptr));
			break;
		default:
			assert(false);
		}

		LIBSAKURA_SYMBOL (Status) sub_status =
		LIBSAKURA_SYMBOL(SubtractBaselineSinusoidUsingCoefficientsFloat)(
				context, num_data, in_data_ptr, num_nwave, nwave, num_coeff,
				coeff_ptr, out_ptr);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kInvalidArgument), sub_status);

		LIBSAKURA_SYMBOL (Status) destroy_status =
				sakura_DestroyBaselineContext(context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);
	}
	cout << endl;
}

/*
 * Test SubtractBaselineSinusoidUsingCoefficientsFloat
 * erroneous cases: bad parameter value cases as follows:
 *     (1) num_data < context->num_bases
 *     (2) num_data < (!=) context->num_basis_data
 *     (3) num_data > (!=) context->num_basis_data
 *     (4) num_nwave == 0
 *     (5) nwave with duplicated elements
 *     (6) nwave with not in ascending order
 *     (7) max_nwave in context < given max_nwave
 *     (8) num_coeff > context->num_bases
 */
TEST_F(BaselineWK, SubtractBaselineSinusoidUsingCoefficientsErroneousCasesBadParameterValue) {
	enum BVItems {
		BV_kDataLTNumBases,
		BV_kDataLTNumBasisData,
		BV_kDataGTNumBasisData,
		BV_kNumNWaveZero,
		BV_kNWaveDuplicated,
		BV_kNWaveNotAscending,
		BV_kGivenTooLargeMaximumNWave,
		BV_kNumCoeffGTNumBases,
		BV_kNumElems
	};
	vector<string> bv_param_names = { "(num_data < context->num_bases)",
			"(num_data < context->num_basis_data)",
			"(num_data > context->num_basis_data)",
			"(clip_threshold_sigma == 0)", "(clip_threshold_sigma < 0)",
			"(num_nwave == 0)", "(nwave duplicated)", "(nwave not ascending)",
			"(context_max_nwave < given_max_nwave)",
			"(num_coeff > context->num_bases)" };
	cout << "    Testing for cases " << endl;

	size_t const num_basis_data = 10;
	size_t const dummy = 1;

	for (BVItems item = static_cast<BVItems>(0); item < BV_kNumElems; item =
			static_cast<BVItems>(item + 1)) {
		cout << "        " << bv_param_names[item]
				<< ((item < BV_kNumElems - 1) ? ", " : "") << endl;
		size_t num_data = num_basis_data;
		size_t context_nwave = 2;
		size_t num_nwave = 3;
		size_t nwave[num_nwave];
		for (size_t i = 0; i < num_nwave; ++i) {
			nwave[i] = i;
		}
		size_t tmp_nwave = nwave[0];
		size_t num_coeff = 5;
		size_t num_coeff_by_nwave =
				(nwave[0] == 0) ? (2 * num_nwave - 1) : (2 * num_nwave);

		switch (item) {
		case BV_kDataLTNumBases:
			num_data = 2;
			break;
		case BV_kDataLTNumBasisData:
			num_data = 5;
			break;
		case BV_kDataGTNumBasisData:
			num_data = 15;
			break;
		case BV_kNumNWaveZero:
			num_nwave = 0;
			break;
		case BV_kNWaveDuplicated:
			nwave[1] = nwave[0];
			break;
		case BV_kNWaveNotAscending:
			tmp_nwave = nwave[1];
			nwave[1] = nwave[0];
			nwave[0] = tmp_nwave;
			break;
		case BV_kGivenTooLargeMaximumNWave:
			nwave[num_nwave-1] = context_nwave + 10;
			break;
		case BV_kNumCoeffGTNumBases:
			num_coeff = num_coeff_by_nwave + 1;
			break;
		default:
			assert(false);
		}

		double coeff[num_coeff];
		SetDoubleConstant(1.0, ELEMENTSOF(coeff), coeff);
		SIMD_ALIGN
		float in_data[num_data];
		SetFloatSinusoidal(num_nwave, nwave, coeff, num_data, in_data);
		SIMD_ALIGN
		bool mask[ELEMENTSOF(in_data)];
		SetBoolConstant(true, ELEMENTSOF(in_data), mask);
		SIMD_ALIGN
		float out[ELEMENTSOF(in_data)];
		LIBSAKURA_SYMBOL(BaselineContext) *context = nullptr;
		LIBSAKURA_SYMBOL (Status) create_status = sakura_CreateBaselineContext(
				LIBSAKURA_SYMBOL(BaselineType_kSinusoid), dummy, dummy,
				context_nwave, num_basis_data, &context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), create_status);

		LIBSAKURA_SYMBOL(Status) sub_status =
				LIBSAKURA_SYMBOL(SubtractBaselineSinusoidUsingCoefficientsFloat)(
						context, num_data, in_data, num_nwave, nwave, num_coeff,
						coeff, out);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kInvalidArgument), sub_status);

		LIBSAKURA_SYMBOL (Status) destroy_status =
				sakura_DestroyBaselineContext(context);
		EXPECT_EQ(LIBSAKURA_SYMBOL(Status_kOK), destroy_status);
	}
}
